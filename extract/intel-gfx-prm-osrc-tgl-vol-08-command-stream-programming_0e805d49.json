{"origin_pdf_path": "https://cdrdv2-public.intel.com/703062/intel-gfx-prm-osrc-tgl-vol-08-command-stream-programming.pdf", "text_in_pdf": "Intel® Iris® Xe and UHD Graphics Open Source  \n\nProgrammer's Reference Manual  \n\nFor the 2020-2021 11th Generation Intel Xeon®, Core™, Celeron®, Pentium® Gold Processors based on the \"Tiger Lake\" Platform  \n\nVolume 8: Command Stream Programming  \n\nDecember 2021, Revision 1.0  \n\nNotices and Disclaimers  \n\nIntel technologies may require enabled hardware, software or service activation.  \n\nNo product or component can be absolutely secure.  \n\nCode names are used by Intel to identify products, technologies, or services that are in development and not publicly available. These are not \"commercial\" names and not intended to function as trademarks  \n\nCustomer is responsible for safety of the overall system, including compliance with applicable safetyrelated requirements or standards.  \n\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exceptions that a) you may publish an unmodified copy and b) code included in this document is licensed subject to Zero-Clause BSD open source license (0BSD). You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document.  \n\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request.  \n\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein.  \n\nIntel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade.  \n\nIntel may make changes to specifications and product descriptions at any time, without notice. Designers must not rely on the absence or characteristics of any features or instructions marked \"reserved\" or \"undefined\". Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them. The information here is subject to change without notice. Do not finalize a design with this information.  \n\n$\\circledcirc$ Intel Corporation. Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries. Other names and brands may be claimed as the property of others.  \n\nTable of Contents  \n\nCommand Stream Programming ..   \nIntroduction. .   \nWorkload Submission and Execution Status 2   \nScheduling and Execlists ..... 2   \nPreemption ........ .... 10   \nExecution Status ... ... 11   \nCommands and Programming Interface . 14   \nCommand Buffers. .. 14   \nCommand Streamer Command Formats . .. 17   \nExecution Control Infrastructure .. 20   \nMI Commands for Graphics Processing Engines . .. 29   \nRegister Access and User Mode Privileges . .. 30   \nContext Management.. .. 43   \nGlobal State .. 44   \nContext State . .. 49  \n\nProducer-Consumer Data ordering for MI Commands ....... 53  \n\nMemory Data Ordering ............ .. 53   \nMMIO Data Ordering. ... 55   \nCommand Fetch . 56   \nAdvanced Command Prefetch . 56   \nSelf Modifying Code. .. 57  \n\nCommand Stream Programming  \n\nIntroduction  \n\nCommand Streamer is the primary interface to the various engines that are part of the graphics hardware.  \n\nThe graphics HW consists of multiple parallel engines that can execute different kinds of workloads. E.g Graphics, Video Decode engine, Video Enhancement Engine and Blitter engine.  \n\nSome product SKU's have multiple instances of an engine (e.g 2 Video Decode engines).  \n\nAs shown in figure 1, each of these engines have their own Command Streamer that is responsible for processing the commands in the workload and enabling execution of the task.  \n\n  \n\nFigure 1: High level view of Command Streamer  \n\nAs shown in the figure, the command streamer is comprised of a Common Front end and an engine specific backend.  \n\nThe common front end allows each engine to provide a uniform software interface (e.g infrastructure for submission of commands, sychronization, etc).\n\nintel.  \n\nThe back ends handle the engine specific commands and the protocols required to control the execution of the underlying engine.  \n\nWorkload Submission and Execution Status  \n\nThis section describes the interface to submit work and obtain status  \n\nScheduling and Execlists  \n\nExecution-List provides a HW-SW interface mechanism to schedule context as a fundamental unit of submission to GFX-device for execution. GFX-device has multiple engines (Graphics, Blitter, Video, Video Enhancement) with each of them having an execution list for context submission. At any given time all engines could be concurrently running different contexts.  \n\nA context is identified with a unique identifier called Context ID. Each context is associated with an address space for memory accesses and is assigned a unique ring buffer for command submission.  \n\nSW submits workload for a context by programming commands in to its assigned ring buffer prior to submitting context to HW (engine) for execution.  \n\nContext State:  \n\nEach context programs the engine state according to its workload requirements. All the hardware state variables of an engine required to execute a context is called context state. Each context has its own context state. Context state gets programmed on execution of commands from the context ring buffer. All the contexts designated to run on an engine have the same context format, however the values may differ based on the individual state programming.  \n\nLogical Context Address:  \n\nEach context is assigned a Logical Context Address to which the context state is saved by the engine on a context getting switched out from execution. Similarly, engine restores the context state from the logical context address of a context on getting switched in for execution.  \n\nLogical context address is an absolute graphics virtual address in global virtual memory. Context state save/restore mechanism by the engine avoids SW from re-programming the state across context switches.  \n\nEach engine has its own hardware state variables and hence they have different context state formats. A context run on a Render engine can't be submitted to Blitter engine and vice-versa and holds true for any other engines.  \n\nContext Submission:  \n\nA context is submitted to an engine for execution by writing the context descriptor to the Execlist Submit Port (ELSP). Refer ELSP for more details. Context descriptor provides the Context ID, Address space, Logical Context Address and context valid. Refer context descriptor for more details.  \n\nLogical context address points to the context state in global virtual memory which has ring buffer details, address space setup details and other important hardware state initialization for the corresponding context. Refer Logical Context Format for more details.  \n\nNote that this mechanism cannot be used when the Execlist Enable bit in the corresponding engines MODE register is not set, i.e GFX_MODE register for Render Engine, BLT_MODE register for Blitter Engine, VCS_MODE register for Video Engine, or VECS_MODE register for Video Enhancement Engine.  \n\nExecution List Submission Port (ELSP)  \n\nExecution List Submit Port is a MMIO register in every engine. Contexts are queued in for submission to the engine by writing the context descriptor to the engine's ELSP. ELSP provides flexibility to queue up to eight contexts at a time for submission called Submission Queue (SQ). SQ is a staging buffer in the engine which can hold up to eight contexts (elements) for submission. ELSP provides a mechanism to load the elements of the SQ in a cyclic order which wraps around to E0 on writing to E7 (E0, E1 ... E7, E0 ..). Each element of the SQ is also individually MMIO mapped which can be written to or read from, this provides an alternate flexible mechanism to independently modify any element of the SQ in any order avoiding ELSP port. The valid bits of the unused context descriptors should be set to $\"0\"$ in a pathological case all the eight elements can have the valid bits of the context descriptors set to $\"0\"$ (Empty Submission Queue).  \n\nWriting to SQ through ELSP or direct MMIO itself doesn't trigger the engine to start executing the elements from the SQ. Engine has to be explicitly notified to start executing the elements from the SQ by writing to the \"Load\" bit in the Execlist Control Register. Engine on detecting Load notification will sample the SQ to its internal execution staging buffer called Execution Queue (EQ). On loading Execution Queue becomes valid. Engine will start executing elements with valid context descriptors in serial order from the valid EQ, starting from E0 followed by E1 followed by E2 and so on to E7, invalid elements are simply skipped by the engine. EQ becomes invalid following execution of E7 making engine idle.  \n\nMoving from one element to the other element in an EQ is called synchronous context switch. Once a context is switched out, the relevant context state and context descriptor doesn't exist in EQ, only way the context can be brought back for execution in to EQ is through a new \"Load\" from SQ. Refer context switch section for more details.  \n\nSW can modify SQ as many times as needed before issuing the \"Load\" command to the engine for execution. SQ contents are retained and not destructed on issuing \"Load\" and SQ contents are also retained across power flows.  \n\nIssuing a \"Load\" command while there is an ongoing element execution from EQ will result in immediate sampling of SQ to EQ and also results in preemption of the executing context on appropriate boundary. Once preemption of the ongoing executing context is complete, engine will start executing from Element-0 of the updated EQ. Preemption of a context is called asynchronous context switch and refer context switch section for more details. Multiple loads occurring while there is an ongoing preemption of an executing context will result in EQ getting updated multiple times, engine will only execute the latest EQ available upon completion of the preemption and will not get to see the intermediate updates.  \n\nExeclist Submit Port Register Execlist Submission Queue Contents Execlist Control Register  \n\nContext Descriptor Format  \n\nContext Descriptor Format  \n\nBefore submitting a context for the first time, the context image must be properly initialized. Proper initialization includes the ring context registers (ring location, head/tail pointers, etc.) and the page directory.  \n\nIf supported in register programming, the Context Restore Inhibit bit in the Context/Save image in memory can be set to prevent restoring garbage engine context. See the Logical Ring Context Format section for details.  \n\nProgramming Note on Context ID field in the Context Descriptor  \n\nThis section describes the current usage by SW.  \n\nGeneral Layout:  \n\n66 26 16 05 ６5 85 75 65 55 455 25 15 04 64 84 74 64 54 44 34 24 14 03 93 83 73 63 53 433 23 13 0682 765422 22 101 ６1 81 71 61 51 41 1 21 11 00 90 80 70 60 50 400 20 10 0Eng.IDSWCounterHW UseSWContextID  \n\nEng. $\\left$ Engine ID (a software defined enum to identify RCS, BCS etc..)  \n\nSW Counter $=$ Submission Counter. (SW generates an unique counter value on every submission to ensure GroupID $^+$ PASID is unique to avoid ambiguity in fault reporting & handling)  \n\nBit $20\\,=$ Is Proxy submission. If Set to true, SW Context ID[19:0] $=$ LRCA [31:20], else it is an index into the Context Pool.  \n\nDirect Submission (Ring 3 to GuC)  \n\nEvery application gets one context ID of their own.  \n\nSW Context $I D+$ Engine $I D+S W$ Counter forms the unique number  \n\nThe Engine ID is used to identify which engine of a given context needs to be put into wait or ready state based on Semphore/Page Fault ID value in Semaphore/Page fault FIFO.  \n\nThis method allows the context to submit work to other engines while its blocked on one.  \n\nProxy Submission (In order submission from Kernel Mode Driver to GuC)  \n\nKMD creates one context for submitting work on behalf of various user mode contexts (user mode application is not using direct submission model).  \n\nThis method has certain key restrictions and behaviors:  \n\n•  Work (LRCA) submitted will be scheduled on the CS in the order it was received.   \n•  KMD uses its SW Context ID in [63:32] but uses the LRCA of the user mode context. o  KMD's LRCA is not used for any work submission.   \n•  If a workload hits a wait event, it does not lose its position in the schedule queue. o  Enforces \"in order\" ness.   \n•  Due to in order execution, same engine - different context semaphore synchronization is not possible. o  Therefore, cross engine sync is simple because it clears the semaphore of the head.   \n•  Due to in order execution, page fault on a context cannot allow a different context on same engine to execute (may preempt to idle as a power optimization).  \n\nThis method allows a clean SW architecture to have KMD submissions and Ring 3 submissions to coexist.  \n\nLogical Ring Context Format  \n\nContext descriptor has the graphics virtual address pointing to the logical context in memory. Logical context has all the details required for an engine to execute a context. This is the only means through which software can pass on all the required information to hardware for executing a context. Engine on selecting a context for execution will restore (fetch-context restore) the logical context from memory to setup the appropriate state in the hardware. Engine on switching out the context from execution saves (store- context save) the latest updated state to logical context in memory, the updated state is result of the command buffer execution.  \n\nThe Logical Context of each engine (Render, Video, Blitter, Video Enhancement ..etc) primarily consists of the following sections:  \n\nPer-Process HW Status Page (4K) Ring Context (Ring Buffer Control Registers, Page Directory Pointers, etc.) Engine Context ( PipelineState, Non-pipelineState, Statistics, MMIO)  \n\nPer-Process of HW status Page (PPHWSP)  \n\nThis is a 4KB scratch space memory allocated for each of the context in global address space. First few cachelines are used by the engine for implicit reports like auto-report of head pointer, timestamp statistics associated with a context execution, rest of the space is available for software as scratch space for reporting fences through MI commands. Context descriptor points to the base of Per-Process HW status page. See the PPHWP format in PPHWSP_LAYOUT.  \n\nLogical Ring Context  \n\nLogical Ring Context starts immediately following the PPHWSP in memory. Logical ring context is five cachelines in size. This is the minimal set of hardware state required to be programmed by SW for setting up memory access and the ring buffer for a context to be executed on an engine. Memory setup is required for appropriate address translation in the memory interface. Ring buffer details the location of the ring buffer in global graphics virtual address space with its corresponding head pointer and the tail pointer. Ring context also has \"Context Save/Restore Control Register-CTXT_SR_CTL\" which details the engine context save/restore format. Engine first restores the Logical Ring Context and upon processing CTXT_SR_CTL it further decides the due course of Engine Context restore. Logical Ring Context is mostly  \n\nintel.  \n\nidentical across all engines. Logical ring context is saved to memory with the latest up to date state when a context is switched out.  \n\nEngine Context  \n\nEngine context starts immediately following the logical ring context in memory. This state is very specific to an engine and differs from engine to engine. This part of the context consists of the state from all the units in the engine that needs to be save/restored across context switches. Engine restores the engine context following the logical ring context restore. It is tedious for software to populate the engine context as per the requirements, it is recommended to implicitly use engine to populate this portion of the context. Below method can be followed to achieve the same:  \n\n•  When a context is submitted for the first time for execution, SW can inhibit engine from restoring engine context by setting the \"Engine Context Restore Inhibit\" bit in CTXT_SR_CTL register of the logical ring context. This will avoid software from populating the Engine Context. Software must program all the state required to initialize the engine in the ring buffer which would initialize the hardware state. On a subsequent context save engine will populate the engine context with appropriate values.   \n•  Above method can be used to create a complete logical context with engine context populated by the hardware. This Logical context can be used as an Golden Context Image or template for subsequently created contexts.  \n\nEngine saves the engine context following the logical ring context on switching out a context.  \n\nThe detailed format of the logical ring context for Blitter, Video, and VideoEnhancement is documented in the Memory Object Overview/Logical Contexts chapter.  \n\nThe detailed formats of the Render Logical Ring and Engine Context, including their size, is mentioned in the Engine Register and State Context topic for each product.  \n\nRINGBUF -- Ring Buffer Registers  \n\nRegisterRING BUFFER TAIL-Ring Buffer TailRING BUFFERH HEAD-Ring BufferHeadRING_BUFFER_START-Ring BufferStartRING G_BUFFER_CTL-Ring Buffer :Control  \n\nCommand Stream Virtual Memory Control  \n\nPer-Process GTT (PPGTT) is setup for an engine (Graphics, Blitter, Video and Video Enhancement) by programming corresponding Page Directory Pointer (PDP) registers listed below. Refer \"Graphics Translation Tables\" in \"Memory Overview\" for more details on Per-Process page table entries and related translations.", "files_in_pdf": [{"path": ".pdf_temp/viewrange_chunk_1_1_5_1762065667/images/k5lp9c.jpg", "size": 292166}, {"path": ".pdf_temp/viewrange_chunk_2_6_10_1762065670/images/dyqnl7.jpg", "size": 74988}, {"path": ".pdf_temp/viewrange_chunk_2_6_10_1762065670/images/fe92o0.jpg", "size": 100459}]}