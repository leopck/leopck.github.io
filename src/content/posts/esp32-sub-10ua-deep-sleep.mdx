---
title: "Achieving Sub-10µA Sleep Current on ESP32: Register-Level Analysis"
description: "A systematic investigation into ESP32 power domains, RTC memory retention, and peripheral leakage. Includes register-level configurations and oscilloscope measurements proving sub-10µA deep sleep."
publishDate: 2024-11-14
category: microcontrollers
tags: [esp32, power-management, low-power, embedded, registers]
difficulty: expert
readingTime: 22
featured: true
---

import Callout from '@/components/mdx/Callout.astro';
import RegisterDiagram from '@/components/mdx/RegisterDiagram.astro';
import MemoryLayout from '@/components/mdx/MemoryLayout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

The ESP32 datasheet claims 10µA deep sleep current. In practice, most developers see 150-500µA. This gap stems from undocumented power domains, peripheral leakage, and default configurations optimized for quick wake-up rather than minimum power. Let's fix that.

## Power Domain Architecture

The ESP32 contains multiple independently-controllable power domains:

<MemoryLayout
  title="ESP32 Power Domain Hierarchy"
  regions={[
    { start: "Domain 0", end: "", name: "Digital Core", size: "~25mA active", color: "red", notes: "CPU, caches, SRAM" },
    { start: "Domain 1", end: "", name: "RTC Fast Memory", size: "~500µA retention", color: "orange", notes: "8KB, code execution" },
    { start: "Domain 2", end: "", name: "RTC Slow Memory", size: "~2µA retention", color: "green", notes: "8KB, variable storage" },
    { start: "Domain 3", end: "", name: "RTC Peripherals", size: "~150µA", color: "purple", notes: "ULP, touch, ADC" },
    { start: "Domain 4", end: "", name: "RTC Core", size: "~6µA", color: "blue", notes: "RTC timer, wakeup" },
  ]}
/>

The critical insight: **default deep sleep keeps Domain 1 (RTC Fast Memory) powered** for fast wake-up. This alone adds 500µA.

## The RTC_CNTL Register Set

Power management is controlled through the RTC_CNTL peripheral. The key registers:

<RegisterDiagram
  name="RTC_CNTL_DIG_PWC_REG"
  address="0x3FF48090"
  bits={[
    { range: "31:22", name: "Reserved", desc: "Reserved", color: "gray" },
    { range: "21", name: "DG_WRAP_FORCE_PU", desc: "Force digital wrapper power up", color: "orange" },
    { range: "20", name: "DG_WRAP_FORCE_PD", desc: "Force digital wrapper power down", color: "green" },
    { range: "19", name: "WIFI_FORCE_PU", desc: "Force WiFi power up", color: "orange" },
    { range: "18", name: "WIFI_FORCE_PD", desc: "Force WiFi power down", color: "green" },
    { range: "17", name: "INTER_RAM4_FORCE_PU", desc: "Force internal SRAM 4 power up", color: "orange" },
    { range: "16", name: "INTER_RAM4_FORCE_PD", desc: "Force internal SRAM 4 power down", color: "green" },
    { range: "15:0", name: "...", desc: "Additional RAM controls", color: "blue" },
  ]}
/>

## Systematic Power Reduction

### Step 1: Disable RTC Fast Memory (Save ~500µA)

```cpp
#include "soc/rtc_cntl_reg.h"
#include "soc/rtc.h"

void configure_rtc_memory_powerdown() {
    // Disable RTC Fast Memory retention during deep sleep
    // This prevents ULP program execution but saves ~500µA
    REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FASTMEM_FORCE_PU);
    REG_SET_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FASTMEM_FORCE_PD);
    
    // Verify the change
    uint32_t pwc_reg = REG_READ(RTC_CNTL_PWC_REG);
    assert((pwc_reg & RTC_CNTL_FASTMEM_FORCE_PU) == 0);
    assert((pwc_reg & RTC_CNTL_FASTMEM_FORCE_PD) != 0);
}
```

<Callout type="warning" title="ULP Compatibility">
  Powering down RTC Fast Memory prevents ULP coprocessor program execution during deep sleep. If you need ULP functionality, you cannot use this optimization.
</Callout>

### Step 2: Disable RTC Peripherals (Save ~150µA)

```cpp
void disable_rtc_peripherals() {
    // Power down touch sensor controller
    REG_SET_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_TOUCH_FORCE_PD);
    
    // Power down SAR ADC
    REG_SET_BIT(SENS_SAR_MEAS_WAIT2_REG, SENS_FORCE_XPD_SAR);
    REG_CLR_BIT(SENS_SAR_MEAS_WAIT2_REG, SENS_FORCE_XPD_SAR);
    
    // Disable brown-out detector during sleep (risky but saves ~10µA)
    // Only do this if your power supply is stable
    REG_SET_BIT(RTC_CNTL_BROWN_OUT_REG, RTC_CNTL_BROWN_OUT_PD_RF_ENA);
}
```

### Step 3: Configure GPIO Isolation (Save 10-100µA)

GPIO leakage is often the hidden power thief:

```cpp
void configure_gpio_isolation() {
    // Isolate all GPIOs during deep sleep
    esp_sleep_config_gpio_isolate();
    
    // For each GPIO, explicitly set the hold state
    for (int i = 0; i < GPIO_NUM_MAX; i++) {
        if (GPIO_IS_VALID_GPIO(i)) {
            // Enable hold during deep sleep
            gpio_hold_en((gpio_num_t)i);
            // Configure as input with pull-down to prevent floating
            gpio_set_direction((gpio_num_t)i, GPIO_MODE_INPUT);
            gpio_set_pull_mode((gpio_num_t)i, GPIO_PULLDOWN_ONLY);
        }
    }
    
    // Critical: Enable deep sleep hold for ALL GPIOs
    gpio_deep_sleep_hold_en();
}
```

<Callout type="danger" title="External Pull-ups">
  External pull-up resistors on GPIOs configured as inputs with internal pull-down create a resistor divider drawing continuous current. A 10kΩ pull-up to 3.3V draws 165µA per GPIO!
</Callout>

### Step 4: Clock Configuration

The RTC uses an internal 150kHz oscillator by default. The 32kHz external crystal is more power-efficient:

```cpp
void configure_rtc_clock() {
    // Use external 32.768kHz crystal (lower power, more accurate)
    rtc_clk_32k_enable(true);
    
    // Wait for crystal to stabilize
    rtc_clk_32k_bootstrap(512);
    
    // Switch RTC clock source
    rtc_clk_slow_src_set(RTC_SLOW_FREQ_32K_XTAL);
    
    // Verify switch was successful
    rtc_slow_freq_t current = rtc_clk_slow_src_get();
    assert(current == RTC_SLOW_FREQ_32K_XTAL);
}
```

<RegisterDiagram
  name="RTC_CNTL_CLK_CONF_REG"
  address="0x3FF48070"
  bits={[
    { range: "31:30", name: "FAST_CLK_RTC_SEL", desc: "Fast clock source: 0=XTAL_DIV, 1=CK8M_D256", color: "blue" },
    { range: "29:28", name: "ANA_CLK_RTC_SEL", desc: "Slow clock source: 0=RC, 1=32K_XTAL, 2=8M_D256", color: "green" },
    { range: "27", name: "CK8M_DIV_SEL", desc: "CK8M divider select", color: "orange" },
    { range: "26:24", name: "CK8M_DIV_SEL_VLD", desc: "Divider valid", color: "gray" },
    { range: "23:0", name: "...", desc: "Additional clock controls", color: "gray" },
  ]}
/>

## The Complete Low-Power Configuration

```cpp
#include "esp_sleep.h"
#include "driver/rtc_io.h"
#include "soc/rtc_cntl_reg.h"
#include "soc/sens_reg.h"

void enter_minimum_power_deep_sleep(uint64_t sleep_duration_us) {
    // Step 1: Configure wake-up source
    esp_sleep_enable_timer_wakeup(sleep_duration_us);
    
    // Step 2: Disable RTC Fast Memory
    esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_FAST_MEM, ESP_PD_OPTION_OFF);
    
    // Step 3: Disable RTC Slow Memory (if not using RTC variables)
    // WARNING: This loses all RTC_DATA_ATTR variables
    esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_SLOW_MEM, ESP_PD_OPTION_OFF);
    
    // Step 4: Disable RTC peripherals
    esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_OFF);
    
    // Step 5: Configure GPIOs
    for (int i = 0; i < GPIO_NUM_MAX; i++) {
        if (rtc_gpio_is_valid_gpio((gpio_num_t)i)) {
            rtc_gpio_isolate((gpio_num_t)i);
        }
    }
    
    // Step 6: Disable WiFi/BT completely
    esp_wifi_stop();
    esp_bt_controller_disable();
    
    // Step 7: Enter deep sleep
    esp_deep_sleep_start();
}
```

## Measurement Results

Using a Keithley 6514 electrometer with 100ms integration time:

<Benchmark
  title="ESP32 Deep Sleep Current Measurements"
  columns={["Configuration", "Current", "Wake Time"]}
  rows={[
    { values: ["Default deep sleep", "147.3 µA", "280ms"], highlight: false },
    { values: ["+ Disable Fast Mem", "42.1 µA", "350ms"], highlight: false },
    { values: ["+ Disable Slow Mem", "28.4 µA", "380ms"], highlight: false },
    { values: ["+ Disable RTC Periph", "12.8 µA", "420ms"], highlight: false },
    { values: ["+ GPIO Isolation", "8.7 µA", "420ms"], highlight: true },
    { values: ["+ 32kHz XTAL", "6.9 µA", "420ms"], highlight: true },
  ]}
  notes="ESP32-WROOM-32, VDD=3.3V, 25°C ambient"
/>

<PerfChart
  title="Power vs Wake Time Trade-off"
  unit="µA"
  data={[
    { label: "Fast Wake (default)", value: 147, color: "red", annotation: "280ms wake" },
    { label: "Balanced", value: 43, color: "orange", annotation: "350ms wake" },
    { label: "Low Power", value: 12, color: "green", annotation: "420ms wake" },
    { label: "Minimum Power", value: 7, color: "blue", annotation: "420ms wake" },
  ]}
/>

## Common Leakage Sources

If you're still above 10µA, check these sources:

1. **PSRAM** (if equipped): Adds 20-40µA in retention mode
2. **USB-UART bridge**: CP2102/CH340 can draw 1-5mA from 3.3V rail
3. **LDO quiescent current**: AMS1117 draws 5mA; use HT7333 (3µA)
4. **LED power indicator**: 1-20mA depending on resistor value
5. **External sensors**: I2C devices often have 1-100µA standby draw

## Oscilloscope Validation

To validate sleep current, use current probe measurements:

```bash
# Sample measurement setup
# - Keysight MSOX3104T oscilloscope
# - Keysight N2820A current probe (10mA range)
# - 1Ω shunt resistor for cross-validation

# Capture deep sleep entry transition
python capture_power_profile.py --duration 10s --rate 100kHz --output sleep_entry.csv
```

The current waveform should show:
- Sharp drop from ~40mA to ~10µA over ~100ms
- Stable plateau at target current
- No periodic spikes (would indicate timer or peripheral activity)

## Conclusion

Achieving datasheet-specified deep sleep current requires understanding the ESP32's power domain architecture and systematically disabling unused subsystems. The trade-off is increased wake-up latency (280ms → 420ms), which may be acceptable for battery-powered IoT applications sleeping for minutes or hours.

For truly battery-powered applications, consider the ESP32-S2 or ESP32-C3 which achieve 5µA deep sleep with default configurations.
