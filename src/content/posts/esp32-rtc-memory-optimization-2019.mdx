---
title: "ESP32 RTC Memory Optimization: Maximizing Deep Sleep State Retention"
author: "stanley-phoong"
description: "Comprehensive guide to ESP32 RTC memory management, optimizing memory usage for deep sleep, and techniques for state retention in ultra-low-power applications."
publishDate: 2019-09-02
category: microcontrollers
tags: [esp32, rtc-memory, deep-sleep, optimization, low-power, embedded]
difficulty: advanced
readingTime: 18
---

import Callout from '@/components/mdx/Callout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

ESP32 RTC memory is the only memory retained during deep sleep. Optimizing RTC memory usage is critical for maintaining state in battery-powered applications.

## RTC Memory Architecture

ESP32 has two types of RTC memory:

<Benchmark
  title="ESP32 RTC Memory Types"
  columns={["Type", "Size", "Retention Current", "Use Case"]}
  rows={[
    { values: ["RTC Fast Memory", "8 KB", "~500 µA", "ULP code execution"], highlight: true },
    { values: ["RTC Slow Memory", "8 KB", "~2 µA", "Variable storage"], highlight: true },
  ]}
/>

## RTC_DATA_ATTR Usage

Variables marked with `RTC_DATA_ATTR` are stored in RTC slow memory:

```cpp
#include "esp_attr.h"

// Variables in RTC slow memory (persist through deep sleep)
RTC_DATA_ATTR int boot_count = 0;
RTC_DATA_ATTR float sensor_readings[100];
RTC_DATA_ATTR uint32_t last_wake_time = 0;
RTC_DATA_ATTR char config_data[256];

void setup() {
    Serial.begin(115200);
    
    // Increment boot count (persists across deep sleep)
    boot_count++;
    Serial.printf("Boot count: %d\n", boot_count);
    
    // Read previous sensor data
    Serial.printf("Previous readings: %d\n", 
                  sizeof(sensor_readings) / sizeof(float));
    
    // Take new reading
    float temperature = read_temperature();
    sensor_readings[boot_count % 100] = temperature;
    
    // Enter deep sleep
    esp_sleep_enable_timer_wakeup(3600 * 1000000);  // 1 hour
    esp_deep_sleep_start();
}
```

**Memory limit**: 8 KB total for all RTC_DATA_ATTR variables

## Memory Usage Analysis

Track RTC memory usage:

```cpp
void analyze_rtc_memory_usage() {
    // Calculate size of RTC variables
    size_t total_size = 0;
    
    total_size += sizeof(int);                    // boot_count: 4 bytes
    total_size += sizeof(float) * 100;            // sensor_readings: 400 bytes
    total_size += sizeof(uint32_t);              // last_wake_time: 4 bytes
    total_size += sizeof(char) * 256;             // config_data: 256 bytes
    
    Serial.printf("Total RTC memory used: %zu bytes\n", total_size);
    Serial.printf("Available: %zu bytes\n", 8192 - total_size);
    Serial.printf("Usage: %.1f%%\n", (total_size / 8192.0) * 100.0);
    
    if (total_size > 8192) {
        Serial.println("ERROR: RTC memory overflow!");
    }
}
```

## Optimization Strategies

### 1. Minimize Variable Sizes

```cpp
// Instead of float (4 bytes), use int16_t (2 bytes) with scaling
RTC_DATA_ATTR int16_t temperature_x10[100];  // Store as 0.1°C units

float read_and_store_temperature(int index) {
    float temp = read_temperature();
    temperature_x10[index] = (int16_t)(temp * 10.0);  // 25.3°C → 253
    return temp;
}

float get_temperature(int index) {
    return temperature_x10[index] / 10.0;  // 253 → 25.3°C
}

// Savings: 400 bytes → 200 bytes (50% reduction)
```

### 2. Pack Data Structures

```cpp
// Packed structure saves memory
struct __attribute__((packed)) SensorData {
    uint16_t temperature : 12;  // 0-4095 (0-409.5°C)
    uint16_t humidity : 10;     // 0-1023 (0-102.3%)
    uint16_t pressure : 14;      // 0-16383 (0-1638.3 hPa)
    uint8_t status : 4;          // Status flags
};

RTC_DATA_ATTR SensorData sensor_history[50];  // 4 bytes each

// Total: 200 bytes vs 600 bytes (unpacked: 3 floats + 1 byte)
```

### 3. Circular Buffer Pattern

```cpp
RTC_DATA_ATTR uint8_t buffer_index = 0;
RTC_DATA_ATTR float circular_buffer[50];  // Fixed size, overwrite oldest

void store_reading(float value) {
    circular_buffer[buffer_index] = value;
    buffer_index = (buffer_index + 1) % 50;  // Wrap around
}

// Only stores last 50 readings, fixed memory usage
```

### 4. Compress Data

```cpp
// Store differences instead of absolute values
RTC_DATA_ATTR float base_temperature = 25.0;
RTC_DATA_ATTR int8_t temperature_deltas[100];  // -128 to +127 (delta in 0.1°C)

void store_temperature_delta(int index, float temp) {
    float delta = (temp - base_temperature) * 10.0;
    temperature_deltas[index] = (int8_t)constrain(delta, -128, 127);
}

float get_temperature(int index) {
    return base_temperature + (temperature_deltas[index] / 10.0);
}

// Savings: 400 bytes → 100 bytes (75% reduction)
```

## RTC Fast Memory (ULP)

RTC fast memory is used for ULP coprocessor code:

```cpp
#include "esp32/ulp.h"

// ULP program runs during deep sleep
const ulp_insn_t ulp_program[] = {
    // Read ADC
    I_MOVI(R0, 0),           // R0 = ADC channel
    I_ADC(R1, R0, 0),        // R1 = ADC reading
    
    // Store in RTC memory
    I_ST(R1, R2, 0),         // Store at RTC memory address
    
    // Increment counter
    I_ADDI(R2, R2, 1),       // R2 = R2 + 1
    
    // Wake main CPU if threshold reached
    I_SUBI(R3, R1, 1000),    // Compare with threshold
    I_JMP(3),                // Jump to wake if needed
    I_WAKE(),                // Wake main CPU
    
    I_HALT(),                // Halt ULP
};

void setup_ulp() {
    // Load ULP program into RTC fast memory
    size_t size = sizeof(ulp_program) / sizeof(ulp_insn_t);
    ulp_process_macros_and_load(0, ulp_program, &size);
    ulp_run(0);
}
```

**Trade-off**: RTC fast memory retention consumes ~500 µA

## Memory Layout Optimization

Organize RTC memory efficiently:

```cpp
// Group related data together
struct __attribute__((packed)) SystemState {
    uint32_t boot_count;
    uint32_t total_uptime_seconds;
    uint8_t error_count;
    uint8_t last_error_code;
    uint16_t reserved;
};

RTC_DATA_ATTR SystemState system_state;

// Use remaining space efficiently
RTC_DATA_ATTR float sensor_data[1900];  // Fill remaining ~7.6 KB

void optimize_layout() {
    // Calculate actual usage
    size_t system_state_size = sizeof(SystemState);  // 12 bytes
    size_t sensor_data_size = sizeof(sensor_data);    // 7600 bytes
    
    size_t total = system_state_size + sensor_data_size;
    Serial.printf("Memory layout:\n");
    Serial.printf("  System state: %zu bytes\n", system_state_size);
    Serial.printf("  Sensor data: %zu bytes\n", sensor_data_size);
    Serial.printf("  Total: %zu / 8192 bytes\n", total);
}
```

## State Persistence Patterns

### Pattern 1: Accumulator

```cpp
RTC_DATA_ATTR uint32_t total_samples = 0;
RTC_DATA_ATTR float sum_temperature = 0.0;

void accumulate_reading(float temp) {
    total_samples++;
    sum_temperature += temp;
}

float get_average() {
    return (total_samples > 0) ? sum_temperature / total_samples : 0.0;
}

// Only stores aggregate, not individual readings
```

### Pattern 2: Windowed Statistics

```cpp
RTC_DATA_ATTR float min_temp = 100.0;
RTC_DATA_ATTR float max_temp = -100.0;
RTC_DATA_ATTR float sum_temp = 0.0;
RTC_DATA_ATTR uint16_t count = 0;

void update_statistics(float temp) {
    if (temp < min_temp) min_temp = temp;
    if (temp > max_temp) max_temp = temp;
    sum_temp += temp;
    count++;
}

void reset_window() {
    min_temp = 100.0;
    max_temp = -100.0;
    sum_temp = 0.0;
    count = 0;
}
```

## Performance Impact

RTC memory access characteristics:

<Benchmark
  title="RTC Memory Access Performance"
  columns={["Operation", "Time", "Notes"]}
  rows={[
    { values: ["Read RTC_DATA_ATTR", "~10 ns", "Fast"], highlight: false },
    { values: ["Write RTC_DATA_ATTR", "~50 ns", "Slower"], highlight: false },
    { values: ["ULP RTC Fast Read", "~1 cycle", "Very fast"], highlight: true },
    { values: ["ULP RTC Fast Write", "~1 cycle", "Very fast"], highlight: true },
  ]}
/>

## Best Practices

1. **Minimize RTC variables**: Only store essential state
2. **Use packed structures**: Reduce memory footprint
3. **Compress data**: Store deltas or scaled values
4. **Circular buffers**: Fixed-size, overwrite oldest
5. **Avoid RTC fast memory**: Unless ULP is needed (saves ~500 µA)

## Conclusion

RTC memory optimization requires:

1. **Understanding memory types**: Fast vs slow, different retention costs
2. **Minimizing usage**: Pack data, compress, use efficient types
3. **Organizing layout**: Group related data, maximize utilization
4. **Choosing patterns**: Accumulator, windowed, circular buffer
5. **Avoiding fast memory**: Unless ULP needed (power cost)

Key strategies:
- Use smallest data types possible
- Pack structures to eliminate padding
- Compress or delta-encode data
- Use circular buffers for fixed memory
- Avoid RTC fast memory unless necessary

Optimize RTC memory to maximize state retention while minimizing power consumption.
