---
title: "STM32 Timer Capture: Measuring Jitter and Latency with Cycle-Level Precision"
author: "stanley-phoong"
description: "How to turn STM32 timers into a precise measurement instrument: input capture, prescalers, interrupt jitter analysis, and optimization techniques to get nanosecond-level timing insight for performance tuning."
publishDate: 2020-07-21
category: microcontrollers
tags: [stm32, timers, input-capture, jitter, latency, optimization, performance]
difficulty: advanced
readingTime: 18
---

import Callout from '@/components/mdx/Callout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

Timers are not just for PWM and periodic interrupts; they’re also **the best performance measurement tool you already have**. With input capture and DWT cycle counters, you can measure:
- IRQ latency
- scheduling jitter
- external event timing
with sub-microsecond precision.

This post focuses on STM32 timer capture as a performance analysis tool.

## Architecture: counter + capture register

A general-purpose timer has:
- up-counter (or up/down)
- capture/compare registers (CCR)
- input channels that can latch the current counter into CCR on edges

<Benchmark
  title="Timer capture components"
  columns={["Element", "Role", "Performance relevance"]}
  rows={[
    { values: ["Counter", "Time base", "Resolution & range"], highlight: true },
    { values: ["Prescaler", "Scales clock", "Trade resolution vs overflow"], highlight: true },
    { values: ["CCR", "Latched value", "Measurement primitive"], highlight: false },
    { values: ["IRQ", "Notifies CPU", "Adds jitter"], highlight: false },
  ]}
/>

## Configure a high-resolution capture (e.g. 84 MHz)

```c
// Example on STM32F4: TIM2 on APB1, timer clock up to 84 MHz
static void tim2_input_capture_init(void) {
  // Enable clocks
  RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
  RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;  // assume PA0 as TIM2_CH1

  // Configure PA0 as AF
  GPIOA->MODER &= ~(3u << (0 * 2));
  GPIOA->MODER |=  (2u << (0 * 2));      // AF
  GPIOA->AFR[0] |= (1u << (0 * 4));      // AF1 = TIM2

  // Timer base: 84 MHz / (PSC+1)
  TIM2->PSC = 0;                          // no prescale -> 84 MHz
  TIM2->ARR = 0xFFFFFFFF;                 // free running

  // Input capture on CH1, rising edge
  TIM2->CCMR1 = (1u << 0);                // CC1S = 01: mapped to TI1
  TIM2->CCER  = TIM_CCER_CC1E;            // enable capture on rising edge

  // Enable interrupt on capture
  TIM2->DIER |= TIM_DIER_CC1IE;
  NVIC_SetPriority(TIM2_IRQn, 1);
  NVIC_EnableIRQ(TIM2_IRQn);

  TIM2->CR1 |= TIM_CR1_CEN;               // start counter
}
```

## Capturing edges and computing periods

```c
volatile uint32_t last_capture = 0;
volatile uint32_t period_cycles = 0;

void TIM2_IRQHandler(void) {
  if (TIM2->SR & TIM_SR_CC1IF) {
    uint32_t now = TIM2->CCR1;
    uint32_t delta = now - last_capture;  // handles wraparound with unsigned
    last_capture = now;
    period_cycles = delta;
    TIM2->SR &= ~TIM_SR_CC1IF;
  }
}

static inline float period_us(void) {
  // timer at 84 MHz -> 11.9 ns per tick
  return period_cycles * (1.0f / 84.0f);
}
```

You now have a **cycle-accurate period measurement** for whatever is driving the pin (e.g. another timer, an external signal, or a GPIO toggle in your ISR).

## Measuring IRQ latency and jitter

Use GPIO toggles + DWT cycle counter:

```c
static void dwt_init(void) {
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CYCCNT = 0;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
}

volatile uint32_t isr_entry_cycles = 0;

void EXTI0_IRQHandler(void) {
  // Read as first instruction
  isr_entry_cycles = DWT->CYCCNT;
  EXTI->PR |= EXTI_PR_PR0;
}
```

Then, from main:

```c
uint32_t t_trigger = DWT->CYCCNT;
// trigger EXTI0 via software or GPIO

// After ISR:
uint32_t latency_cycles = isr_entry_cycles - t_trigger;
float latency_us = latency_cycles / (SystemCoreClock / 1e6f);
```

Repeat many times, record min/avg/max to see jitter.

<PerfChart
  title="IRQ latency histogram (example)"
  type="bar"
  data={{
    labels: ["1.0µs", "1.2µs", "1.4µs", "1.6µs", "1.8µs", "2.0µs"],
    datasets: [{
      label: "Count",
      data: [3, 15, 40, 25, 10, 2],
      backgroundColor: "#3b82f6",
    }]
  }}
/>

## Optimization levers

To reduce **latency and jitter**:
- raise **interrupt priority**
- avoid long critical sections (`__disable_irq` windows)
- move heavy work out of ISR into a deferred handler
- pin hot code in faster memory (ITCM on some MCUs)

<Benchmark
  title="Impact of common changes (example)"
  columns={["Change", "p50 latency", "p99 latency"]}
  rows={[
    { values: ["Baseline", "1.6µs", "3.2µs"], highlight: false },
    { values: ["Raise IRQ priority", "1.4µs", "2.3µs"], highlight: true },
    { values: ["Shorter ISR (defer work)", "1.4µs", "1.8µs"], highlight: true },
  ]}
/>

## Takeaways

- Timers + input capture give you **precise period and jitter data**.
- Combining TIM capture with **DWT cycle counter** lets you isolate ISR latency vs hardware delays.
- Use these tools not just for application timing, but to **measure the impact** of every optimization you make in firmware.

