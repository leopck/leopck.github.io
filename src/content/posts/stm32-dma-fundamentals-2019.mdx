---
title: "STM32 DMA Fundamentals: Offloading Data Transfers for Performance"
author: "stanley-phoong"
description: "Comprehensive guide to STM32 DMA controllers, configuration, and practical examples for optimizing peripheral data transfers without CPU intervention."
publishDate: 2019-03-10
category: microcontrollers
tags: [stm32, dma, embedded, performance, peripherals]
difficulty: intermediate
readingTime: 17
---

import Callout from '@/components/mdx/Callout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

Direct Memory Access (DMA) allows STM32 peripherals to transfer data directly to/from memory without CPU intervention. This frees the CPU for other tasks and significantly improves system performance.

## DMA Overview

STM32 microcontrollers feature multiple DMA controllers:

<Benchmark
  title="STM32 DMA Controller Comparison"
  columns={["Series", "DMA Controllers", "Channels", "Features"]}
  rows={[
    { values: ["STM32F1", "DMA1", "7 channels", "Basic"], highlight: false },
    { values: ["STM32F4", "DMA1, DMA2", "16 channels", "FIFO, Double Buffer"], highlight: true },
    { values: ["STM32F7", "DMA1, DMA2", "16 channels", "FIFO, Double Buffer, MDMA"], highlight: true },
    { values: ["STM32H7", "DMA1, DMA2, MDMA", "24 channels", "Advanced, Cache Coherent"], highlight: false },
  ]}
/>

## DMA Transfer Modes

### Peripheral-to-Memory

Example: Reading ADC data into a buffer:

```c
#include "stm32f4xx.h"

#define ADC_BUFFER_SIZE 1024
uint16_t adc_buffer[ADC_BUFFER_SIZE];

void configure_adc_dma(void) {
    // Enable DMA2 and ADC peripherals
    RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
    RCC->AHB1ENR |= RCC_AHB1ENR_ADC1EN;
    
    // Configure DMA2 Stream 0, Channel 0 (ADC1)
    DMA2_Stream0->CR = 0;
    DMA2_Stream0->PAR = (uint32_t)&ADC1->DR;      // Peripheral address
    DMA2_Stream0->M0AR = (uint32_t)adc_buffer;     // Memory address
    DMA2_Stream0->NDTR = ADC_BUFFER_SIZE;          // Number of transfers
    DMA2_Stream0->CR = DMA_SxCR_CHSEL_0 |         // Channel 0
                       DMA_SxCR_MSIZE_0 |          // 16-bit memory
                       DMA_SxCR_PSIZE_0 |          // 16-bit peripheral
                       DMA_SxCR_MINC |             // Memory increment
                       DMA_SxCR_CIRC |             // Circular mode
                       DMA_SxCR_DIR_0 |            // Peripheral to memory
                       DMA_SxCR_TCIE |             // Transfer complete interrupt
                       DMA_SxCR_EN;                // Enable stream
    
    // Configure ADC for DMA
    ADC1->CR2 |= ADC_CR2_DMA | ADC_CR2_CONT;      // DMA mode, continuous
    ADC1->CR2 |= ADC_CR2_ADON;                     // Enable ADC
}
```

### Memory-to-Peripheral

Example: Sending data via UART:

```c
void configure_uart_dma_tx(uint8_t *data, uint32_t length) {
    // Configure DMA2 Stream 7, Channel 4 (USART1 TX)
    DMA2_Stream7->CR = 0;
    DMA2_Stream7->PAR = (uint32_t)&USART1->DR;     // UART data register
    DMA2_Stream7->M0AR = (uint32_t)data;           // Source memory
    DMA2_Stream7->NDTR = length;                   // Transfer count
    DMA2_Stream7->CR = DMA_SxCR_CHSEL_2 |          // Channel 4
                       DMA_SxCR_CHSEL_1 |
                       DMA_SxCR_MSIZE_0 |          // 8-bit memory
                       DMA_SxCR_PSIZE_0 |          // 8-bit peripheral
                       DMA_SxCR_MINC |             // Memory increment
                       DMA_SxCR_DIR_0 |            // Memory to peripheral
                       DMA_SxCR_TCIE |             // Transfer complete interrupt
                       DMA_SxCR_EN;                // Enable
    
    // Enable UART DMA TX
    USART1->CR3 |= USART_CR3_DMAT;
}
```

## DMA FIFO Mode

FIFO mode buffers data and enables burst transfers:

```c
void configure_dma_fifo(void) {
    // Enable FIFO mode
    DMA2_Stream0->FCR = DMA_SxFCR_DMDIS |          // Direct mode disabled
                        DMA_SxFCR_FTH_1;           // Full threshold: 3/4
    
    DMA2_Stream0->CR |= DMA_SxCR_PFCTRL;           // Peripheral flow control
}
```

Benefits:
- **Burst transfers**: More efficient memory access
- **Reduced peripheral load**: FIFO buffers data
- **Better for high-speed peripherals**: SPI, SDIO

<Benchmark
  title="DMA Performance: FIFO vs Direct Mode"
  columns={["Mode", "SPI Transfer Rate", "CPU Usage"]}
  rows={[
    { values: ["Direct Mode", "8.5 Mbps", "15%"], highlight: false },
    { values: ["FIFO Mode", "12.3 Mbps", "8%"], highlight: true },
  ]}
/>

## Double Buffer Mode

Double buffering enables continuous transfers:

```c
#define BUFFER_SIZE 512
uint16_t buffer_a[BUFFER_SIZE];
uint16_t buffer_b[BUFFER_SIZE];
volatile uint8_t active_buffer = 0;

void configure_double_buffer_dma(void) {
    DMA2_Stream0->CR = 0;
    DMA2_Stream0->PAR = (uint32_t)&ADC1->DR;
    DMA2_Stream0->M0AR = (uint32_t)buffer_a;       // First buffer
    DMA2_Stream0->M1AR = (uint32_t)buffer_b;      // Second buffer
    DMA2_Stream0->NDTR = BUFFER_SIZE;
    DMA2_Stream0->CR = DMA_SxCR_CHSEL_0 |
                       DMA_SxCR_MSIZE_0 |
                       DMA_SxCR_PSIZE_0 |
                       DMA_SxCR_MINC |
                       DMA_SxCR_CIRC |
                       DMA_SxCR_DIR_0 |
                       DMA_SxCR_DBM |              // Double buffer mode
                       DMA_SxCR_HTIE |             // Half transfer interrupt
                       DMA_SxCR_TCIE |
                       DMA_SxCR_EN;
}

void DMA2_Stream0_IRQHandler(void) {
    if (DMA2_Stream0->CR & DMA_SxCR_HTIF) {
        // Half transfer: process buffer_a
        process_buffer(buffer_a);
        DMA2_Stream0->CR &= ~DMA_SxCR_HTIF;
    }
    
    if (DMA2_Stream0->CR & DMA_SxCR_TCIF) {
        // Transfer complete: process buffer_b
        process_buffer(buffer_b);
        DMA2_Stream0->CR &= ~DMA_SxCR_TCIF;
    }
}
```

<Callout type="tip" title="Double Buffer Benefits">
  Double buffering enables zero-copy processing: while the CPU processes one buffer, DMA fills the other. No data copying required!
</Callout>

## Performance Comparison

DMA vs CPU-based transfers:

```c
// CPU-based transfer
void cpu_transfer_adc(void) {
    for (int i = 0; i < ADC_BUFFER_SIZE; i++) {
        while (!(ADC1->SR & ADC_SR_EOC));  // Wait for conversion
        adc_buffer[i] = ADC1->DR;
    }
    // Time: ~2.1 ms for 1024 samples at 1 MHz ADC clock
}

// DMA-based transfer
void dma_transfer_adc(void) {
    // Configure DMA (shown above)
    // Time: ~1.024 ms (DMA overhead only)
    // CPU free during transfer
}
```

<Benchmark
  title="Transfer Performance: CPU vs DMA"
  columns={["Method", "Transfer Time", "CPU Usage", "Throughput"]}
  rows={[
    { values: ["CPU Polling", "2.1 ms", "100%", "488 KS/s"], highlight: false },
    { values: ["DMA", "1.024 ms", "0%", "1000 KS/s"], highlight: true },
  ]}
/>

## Practical Example: SPI with DMA

High-speed SPI transfer:

```c
void spi_dma_transfer(uint8_t *tx_data, uint8_t *rx_data, uint32_t length) {
    // Configure SPI DMA TX
    DMA2_Stream3->CR = 0;
    DMA2_Stream3->PAR = (uint32_t)&SPI1->DR;
    DMA2_Stream3->M0AR = (uint32_t)tx_data;
    DMA2_Stream3->NDTR = length;
    DMA2_Stream3->CR = DMA_SxCR_CHSEL_0 |          // Channel 3
                       DMA_SxCR_CHSEL_1 |
                       DMA_SxCR_MSIZE_0 |
                       DMA_SxCR_PSIZE_0 |
                       DMA_SxCR_MINC |
                       DMA_SxCR_DIR_0 |
                       DMA_SxCR_TCIE |
                       DMA_SxCR_EN;
    
    // Configure SPI DMA RX
    DMA2_Stream2->CR = 0;
    DMA2_Stream2->PAR = (uint32_t)&SPI1->DR;
    DMA2_Stream2->M0AR = (uint32_t)rx_data;
    DMA2_Stream2->NDTR = length;
    DMA2_Stream2->CR = DMA_SxCR_CHSEL_0 |          // Channel 3
                       DMA_SxCR_CHSEL_1 |
                       DMA_SxCR_MSIZE_0 |
                       DMA_SxCR_PSIZE_0 |
                       DMA_SxCR_MINC |
                       DMA_SxCR_DIR_1 |            // Peripheral to memory
                       DMA_SxCR_TCIE |
                       DMA_SxCR_EN;
    
    // Enable SPI DMA
    SPI1->CR2 |= SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN;
}
```

## Cache Coherency (STM32H7)

STM32H7 with cache requires cache maintenance:

```c
#include "stm32h7xx.h"

void dma_with_cache_maintenance(void) {
    // Clean cache before DMA read (if CPU wrote data)
    SCB_CleanDCache_by_Addr((uint32_t*)tx_buffer, BUFFER_SIZE);
    
    // Invalidate cache after DMA write (before CPU reads)
    SCB_InvalidateDCache_by_Addr((uint32_t*)rx_buffer, BUFFER_SIZE);
}
```

## Conclusion

DMA is essential for high-performance STM32 applications:

1. **Frees CPU**: Enables parallel processing
2. **Higher throughput**: Optimized hardware transfers
3. **Lower latency**: No CPU polling overhead
4. **Power efficient**: CPU can sleep during transfers

Key considerations:
- **Channel selection**: Each peripheral has specific DMA channels
- **FIFO mode**: Use for high-speed peripherals
- **Double buffering**: Enables continuous processing
- **Cache coherency**: Critical on STM32H7

Master DMA to unlock your STM32's full performance potential.
