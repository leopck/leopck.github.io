---
title: "STM32 Clock Optimization: Maximizing Performance While Minimizing Power"
author: "stanley-phoong"
description: "Deep dive into STM32 clock configuration, PLL optimization, peripheral clock gating, and dynamic frequency scaling for optimal performance-power trade-offs."
publishDate: 2019-07-16
category: microcontrollers
tags: [stm32, clock, optimization, power, performance, embedded]
difficulty: advanced
readingTime: 20
---

import Callout from '@/components/mdx/Callout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

STM32 clock configuration directly impacts both performance and power consumption. Understanding clock domains, PLL configuration, and dynamic scaling is essential for optimization.

## STM32 Clock Architecture

STM32 features multiple clock domains:

<Benchmark
  title="STM32F4 Clock Domains"
  columns={["Domain", "Source", "Max Frequency", "Power Impact"]}
  rows={[
    { values: ["SYSCLK", "HSI/PLL/HSE", "168 MHz", "High"], highlight: true },
    { values: ["AHB", "SYSCLK", "168 MHz", "High"], highlight: false },
    { values: ["APB1", "AHB", "42 MHz", "Medium"], highlight: false },
    { values: ["APB2", "AHB", "84 MHz", "Medium"], highlight: false },
    { values: ["RTC", "LSE/LSI", "32.768 kHz", "Low"], highlight: false },
  ]}
/>

## PLL Configuration

Optimizing PLL for maximum performance:

```c
#include "stm32f4xx.h"

void configure_pll_168mhz(void) {
    // Enable HSE (8 MHz external crystal)
    RCC->CR |= RCC_CR_HSEON;
    while (!(RCC->CR & RCC_CR_HSERDY));
    
    // Configure PLL: HSE / M * N / P
    // Target: 168 MHz
    // HSE = 8 MHz
    // M = 8, N = 336, P = 2
    // PLL = 8 / 8 * 336 / 2 = 168 MHz
    
    RCC->PLLCFGR = (8 << 0) |           // PLLM = 8
                   (336 << 6) |         // PLLN = 336
                   (0 << 16) |          // PLLP = 2 (00 = /2)
                   (RCC_PLLCFGR_PLLSRC_HSE);  // PLL source = HSE
    
    // Enable PLL
    RCC->CR |= RCC_CR_PLLON;
    while (!(RCC->CR & RCC_CR_PLLRDY));
    
    // Configure flash latency (required for >150 MHz)
    FLASH->ACR |= FLASH_ACR_LATENCY_5WS;  // 5 wait states
    
    // Configure prescalers
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1 |    // AHB = SYSCLK / 1 = 168 MHz
                 RCC_CFGR_PPRE1_DIV4 |   // APB1 = AHB / 4 = 42 MHz
                 RCC_CFGR_PPRE2_DIV2;    // APB2 = AHB / 2 = 84 MHz
    
    // Switch to PLL
    RCC->CFGR |= RCC_CFGR_SW_PLL;
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}
```

## Dynamic Voltage and Frequency Scaling (DVFS)

Adjust frequency based on workload:

```c
typedef enum {
    CLOCK_LOW = 0,      // 24 MHz (low power)
    CLOCK_MEDIUM = 1,   // 84 MHz (balanced)
    CLOCK_HIGH = 2      // 168 MHz (maximum)
} clock_speed_t;

void set_system_clock(clock_speed_t speed) {
    switch (speed) {
        case CLOCK_LOW:
            // Switch to HSI, divide by 7
            RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_HSI;
            RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_HPRE) | RCC_CFGR_HPRE_DIV7;
            // Result: 16 MHz / 1 = 16 MHz (simplified)
            break;
            
        case CLOCK_MEDIUM:
            // Use PLL at 84 MHz
            configure_pll_84mhz();
            break;
            
        case CLOCK_HIGH:
            // Use PLL at 168 MHz
            configure_pll_168mhz();
            break;
    }
}

void optimize_clock_for_task(void) {
    // Low frequency for idle
    set_system_clock(CLOCK_LOW);
    // Current: ~20 mA
    
    // High frequency for computation
    set_system_clock(CLOCK_HIGH);
    // Current: ~80 mA
    
    // Perform computation
    heavy_computation();
    
    // Return to low frequency
    set_system_clock(CLOCK_LOW);
}
```

<PerfChart
  title="Power Consumption vs Clock Frequency"
  type="line"
  data={{
    labels: ["16 MHz", "48 MHz", "84 MHz", "120 MHz", "168 MHz"],
    datasets: [{
      label: "Current (mA)",
      data: [18, 32, 48, 65, 82],
      borderColor: "#ef4444",
    }]
  }}
/>

## Peripheral Clock Gating

Disable unused peripherals to save power:

```c
void optimize_peripheral_clocks(void) {
    // Enable only needed peripherals
    RCC->AHB1ENR = 0;  // Clear all
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;  // GPIOA only
    
    RCC->APB1ENR = 0;  // Clear all
    // Enable only what's needed
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;  // UART2 only
    
    RCC->APB2ENR = 0;  // Clear all
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN;  // UART1 only
    
    // Disable unused peripherals save power
    // Each enabled peripheral adds ~1-5 mA
}
```

**Power savings**: 10-30 mA by disabling unused peripherals

## Clock Prescaler Optimization

Optimize prescalers for peripheral requirements:

```c
void optimize_prescalers(void) {
    // APB1 peripherals (UART, SPI, I2C)
    // Max frequency: 42 MHz
    RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_PPRE1) | RCC_CFGR_PPRE1_DIV4;
    // APB1 = 168 / 4 = 42 MHz (optimal)
    
    // APB2 peripherals (SPI1, USART1, ADC)
    // Max frequency: 84 MHz
    RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_PPRE2) | RCC_CFGR_PPRE2_DIV2;
    // APB2 = 168 / 2 = 84 MHz (optimal)
    
    // Timer clocks (if APB prescaler > 1, timers run at 2x APB)
    // APB1 = 42 MHz → Timer = 84 MHz
    // APB2 = 84 MHz → Timer = 168 MHz
}
```

## Sleep Mode Clock Management

Optimize clocks for sleep modes:

```c
void enter_stop_mode(void) {
    // Reduce clock before sleep
    set_system_clock(CLOCK_LOW);
    
    // Configure for STOP mode
    PWR->CR |= PWR_CR_LPDS;  // Low-power deep sleep
    
    // Enter STOP mode
    __WFI();  // Wait for interrupt
    
    // On wake, clocks return to previous state
    // Reconfigure if needed
    set_system_clock(CLOCK_HIGH);
}
```

## Performance vs Power Analysis

```c
void benchmark_clock_impact(void) {
    uint32_t iterations = 1000000;
    uint32_t start, end;
    
    // Test at different frequencies
    clock_speed_t speeds[] = {CLOCK_LOW, CLOCK_MEDIUM, CLOCK_HIGH};
    const char* names[] = {"Low (16 MHz)", "Medium (84 MHz)", "High (168 MHz)"};
    
    for (int i = 0; i < 3; i++) {
        set_system_clock(speeds[i]);
        
        // Measure computation time
        start = DWT->CYCCNT;
        for (uint32_t j = 0; j < iterations; j++) {
            __NOP();  // Dummy computation
        }
        end = DWT->CYCCNT;
        
        uint32_t cycles = end - start;
        float time_ms = cycles / (SystemCoreClock / 1000.0);
        
        printf("%s: %lu cycles, %.2f ms\n", names[i], cycles, time_ms);
    }
}
```

<Benchmark
  title="Performance vs Power Trade-off"
  columns={["Frequency", "Execution Time", "Power", "Energy per Task"]}
  rows={[
    { values: ["16 MHz", "125 ms", "18 mA", "2.25 mAs"], highlight: false },
    { values: ["84 MHz", "24 ms", "48 mA", "1.15 mAs"], highlight: true },
    { values: ["168 MHz", "12 ms", "82 mA", "0.98 mAs"], highlight: true },
  ]}
/>

<Callout type="tip" title="Energy Optimization">
  Higher frequency completes tasks faster, potentially saving total energy despite higher power consumption. Use DVFS to match frequency to workload.
</Callout>

## Real-Time Constraints

Meeting real-time deadlines:

```c
void real_time_task(void) {
    // Task must complete in 1 ms
    uint32_t deadline_cycles = SystemCoreClock / 1000;  // Cycles in 1 ms
    
    // Measure task execution
    uint32_t start = DWT->CYCCNT;
    process_task();
    uint32_t elapsed = DWT->CYCCNT - start;
    
    if (elapsed > deadline_cycles) {
        // Increase clock frequency
        set_system_clock(CLOCK_HIGH);
    } else {
        // Can reduce frequency
        set_system_clock(CLOCK_MEDIUM);
    }
}
```

## Clock Domain Isolation

Isolate clock domains for power savings:

```c
void isolate_clock_domains(void) {
    // Stop clocks to unused domains
    // Example: Stop APB2 if only using APB1 peripherals
    
    // Configure clock gating
    RCC->AHB1LPENR = 0;  // Disable low-power mode for AHB1
    RCC->APB1LPENR = 0;  // Disable low-power mode for APB1
    RCC->APB2LPENR = 0;  // Disable low-power mode for APB2
    
    // In STOP mode, only RTC domain remains active
}
```

## Optimization Strategies

1. **Use maximum frequency** for compute-intensive tasks
2. **Reduce frequency** during idle periods
3. **Gate unused peripherals** to save power
4. **Optimize prescalers** for peripheral requirements
5. **Use sleep modes** with appropriate clock configuration

## Conclusion

STM32 clock optimization requires:

1. **Understanding clock domains**: SYSCLK, AHB, APB1, APB2
2. **PLL configuration**: Maximize frequency within constraints
3. **DVFS**: Match frequency to workload
4. **Clock gating**: Disable unused peripherals
5. **Prescaler optimization**: Match peripheral requirements

Key strategies:
- Maximize frequency for performance-critical tasks
- Reduce frequency during idle
- Gate unused peripheral clocks
- Use sleep modes with low-frequency clocks
- Balance performance and power

Optimize clocks to achieve required performance while minimizing power consumption.
