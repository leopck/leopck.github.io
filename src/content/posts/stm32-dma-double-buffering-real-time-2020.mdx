---
title: "STM32 Double-Buffered DMA: Sustained Real-Time Throughput Without Dropping Samples"
author: "stanley-phoong"
description: "A performance-first design pattern for STM32: circular + double-buffered DMA with half-transfer interrupts. Includes cycle budgeting, cache coherency gotchas, and a reference architecture for audio/sensor pipelines."
publishDate: 2020-04-23
category: microcontrollers
tags: [stm32, dma, double-buffer, real-time, throughput, optimization, performance]
difficulty: expert
readingTime: 19
---

import Callout from '@/components/mdx/Callout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

The fastest way to miss a real-time deadline on an MCU is to move bytes with the CPU. The fastest way to *never* miss a deadline is to make DMA and peripherals do the boring work while the CPU only touches completed buffers.

This post lays out a **double-buffered DMA** pattern you can reuse for:
- ADC sampling
- I2S audio capture/playback
- SPI sensor bursts
- UART high-rate logging

## The problem: CPU-driven IO doesn't scale

Polling or per-sample interrupts look simple but waste cycles on “bookkeeping”:

```c
// Anti-pattern: per-sample handling (ISR or polling)
void ADC_IRQHandler(void) {
  uint16_t sample = ADC1->DR;
  process_sample(sample);  // too slow once rates go up
}
```

At 48 kHz audio, you have **20.8 µs per sample**. With any DSP, filtering, or compression, you’ll get crushed by overhead.

## The pattern: circular DMA + HT/TC interrupts

Use one DMA stream in circular mode and treat the buffer as two halves:
- **HT (half transfer)** fires when first half filled
- **TC (transfer complete)** fires when second half filled

CPU processes half-buffer chunks while DMA continues filling the other half.

<Benchmark
  title="Why half-buffer interrupts win"
  columns={["Approach", "Interrupt rate", "CPU overhead", "Risk"]}
  rows={[
    { values: ["Per-sample ISR", "Fs (e.g., 48k/s)", "High", "High (jitter)"], highlight: false },
    { values: ["Half-buffer (HT/TC)", "2·Fs/N", "Low", "Low"], highlight: true },
  ]}
/>

## Concrete example: ADC @ 200 kS/s with 1024-sample buffer

- Sample rate: 200,000 samples/s
- Buffer: 1024 samples
- HT/TC interrupts per second: \(2 \cdot 200000 / 1024 \approx 391\) IRQ/s

That’s manageable.

## STM32 configuration (register-level sketch)

```c
#define BUF_SAMPLES 1024
static uint16_t adc_buf[BUF_SAMPLES];

static inline void dma_adc_start(void) {
  // (1) Enable clocks: DMA + ADC + GPIO as needed
  RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
  RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

  // (2) Configure ADC (simplified)
  ADC1->CR2 |= ADC_CR2_DMA | ADC_CR2_DDS; // DMA + continuous DMA requests

  // (3) Configure DMA stream for ADC1->DR to adc_buf
  DMA2_Stream0->CR = 0;
  while (DMA2_Stream0->CR & DMA_SxCR_EN) {}

  DMA2_Stream0->PAR  = (uint32_t)&ADC1->DR;
  DMA2_Stream0->M0AR = (uint32_t)adc_buf;
  DMA2_Stream0->NDTR = BUF_SAMPLES;

  DMA2_Stream0->CR =
      (0 << DMA_SxCR_DIR_Pos) |     // P2M
      DMA_SxCR_MINC |               // increment memory
      DMA_SxCR_CIRC |               // circular mode
      DMA_SxCR_MSIZE_0 |            // 16-bit mem
      DMA_SxCR_PSIZE_0 |            // 16-bit peripheral
      DMA_SxCR_HTIE |               // half transfer interrupt
      DMA_SxCR_TCIE;                // transfer complete interrupt

  DMA2_Stream0->CR |= DMA_SxCR_EN;
  ADC1->CR2 |= ADC_CR2_ADON;
}
```

ISR does *not* process samples; it just schedules work.

```c
volatile uint8_t work_ht = 0;
volatile uint8_t work_tc = 0;

void DMA2_Stream0_IRQHandler(void) {
  if (DMA2->LISR & DMA_LISR_HTIF0) {
    DMA2->LIFCR = DMA_LIFCR_CHTIF0;
    work_ht = 1;
  }
  if (DMA2->LISR & DMA_LISR_TCIF0) {
    DMA2->LIFCR = DMA_LIFCR_CTCIF0;
    work_tc = 1;
  }
}

static inline void process_ready_blocks(void) {
  if (work_ht) {
    work_ht = 0;
    process_block(&adc_buf[0], BUF_SAMPLES/2);
  }
  if (work_tc) {
    work_tc = 0;
    process_block(&adc_buf[BUF_SAMPLES/2], BUF_SAMPLES/2);
  }
}
```

## Cycle budgeting (the part most people skip)

You must ensure `process_block()` completes before DMA wraps around.

Budget:
\[
T_{block} = \frac{N/2}{F_s}
\]
and CPU cycles available:
\[
C_{avail} = T_{block} \cdot f_{cpu}
\]

Example: \(F_s=200k\), \(N=1024\) → \(T_{block}=2.56\) ms  
At \(f_{cpu}=168\) MHz → \(C_{avail}\approx 430k\) cycles.

<Callout type="tip" title="Rule of thumb">
  Keep worst-case processing under ~60–70% of your half-buffer budget to leave headroom for interrupts, cache effects, and jitter.
</Callout>

## Cache coherency gotcha (STM32F7/H7)

If your MCU has D-cache, DMA writes will not automatically invalidate cache lines. You must invalidate before CPU reads:

```c
// invalidate cache lines covering the block DMA wrote
SCB_InvalidateDCache_by_Addr((uint32_t*)block_ptr, block_bytes);
```

And if DMA reads buffers the CPU wrote (TX), clean cache first:

```c
SCB_CleanDCache_by_Addr((uint32_t*)tx_ptr, tx_bytes);
```

<Callout type="warning" title="If you skip this">
  You will see “random” glitches: repeated samples, stale buffers, or sporadic corruption that only appears at higher throughput.
</Callout>

## Performance: what you should expect

<Benchmark
  title="Typical improvements vs CPU IO"
  columns={["Pipeline", "CPU-driven IO", "DMA double-buffer", "Impact"]}
  rows={[
    { values: ["ADC capture @ 200 kS/s", "High CPU, jitter", "Low CPU, stable", "Often 5–20× less overhead"], highlight: true },
    { values: ["I2S audio @ 48 kHz", "ISR-heavy", "Block processing", "Transforms “impossible” into routine"], highlight: true },
  ]}
/>

<PerfChart
  title="Interrupt rate vs buffer size (Fs=200 kS/s)"
  type="line"
  data={{
    labels: ["256", "512", "1024", "2048", "4096"],
    datasets: [{
      label: "HT/TC IRQ/s",
      data: [1562, 781, 391, 195, 98],
      borderColor: "#3b82f6",
    }]
  }}
/>

## Practical tuning knobs

- **Buffer size**: larger → fewer IRQs, more latency
- **Processing granularity**: half vs quarter buffer
- **DMA FIFO / burst** (where available): better bus efficiency
- **Priority**: DMA stream priority vs other bus masters
- **Pin hot loops** in ITCM (H7) for deterministic compute

## Conclusion

Double-buffered DMA is the most reusable real-time optimization pattern on STM32:
- It turns per-sample work into **block work**
- It reduces jitter by **removing CPU from the IO path**
- It makes throughput predictable because you can **cycle-budget** it

Use it anywhere you want sustained performance without surprises.

