---
title: "ESP32 Power Management: Understanding Sleep Modes and Current Consumption"
author: "stanley-phoong"
description: "Comprehensive analysis of ESP32 power modes, measured current consumption, and practical techniques for battery-powered applications."
publishDate: 2019-01-28
category: microcontrollers
tags: [esp32, power-management, low-power, embedded, battery]
difficulty: intermediate
readingTime: 16
---

import Callout from '@/components/mdx/Callout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

The ESP32 offers multiple power modes, each trading functionality for reduced current consumption. Understanding these modes is critical for battery-powered IoT applications.

## ESP32 Power Modes

The ESP32 supports five main power modes:

<Benchmark
  title="ESP32 Power Mode Comparison"
  columns={["Mode", "Current", "Wake Time", "CPU", "WiFi", "RAM Retention"]}
  rows={[
    { values: ["Active", "80-240 mA", "N/A", "Yes", "Yes", "Full"], highlight: false },
    { values: ["Modem Sleep", "20-30 mA", "~1 ms", "Yes", "No", "Full"], highlight: false },
    { values: ["Light Sleep", "0.8-1.2 mA", "~1 ms", "No", "No", "Full"], highlight: true },
    { values: ["Deep Sleep", "10-150 µA", "~200 ms", "No", "No", "RTC Only"], highlight: true },
    { values: ["Hibernation", "5-10 µA", "~1 s", "No", "No", "None"], highlight: false },
  ]}
/>

## Active Mode Current Consumption

Active mode current varies dramatically based on CPU frequency and WiFi state:

```cpp
#include "esp_pm.h"
#include "esp_wifi.h"

void measure_active_current() {
    // Configure power management
    esp_pm_config_esp32_t pm_config = {
        .max_freq_mhz = 240,
        .min_freq_mhz = 80,
        .light_sleep_enable = false
    };
    esp_pm_configure(&pm_config);
    
    // Measure at different frequencies
    int frequencies[] = {80, 160, 240};
    
    for (int freq : frequencies) {
        setCpuFrequencyMhz(freq);
        
        // With WiFi
        WiFi.mode(WIFI_STA);
        WiFi.begin("SSID", "password");
        delay(1000);
        // Measure: ~150-240 mA at 240 MHz
        
        // Without WiFi
        WiFi.mode(WIFI_OFF);
        // Measure: ~80-120 mA at 240 MHz
    }
}
```

<PerfChart
  title="Active Mode Current vs CPU Frequency"
  type="line"
  data={{
    labels: ["80 MHz", "160 MHz", "240 MHz"],
    datasets: [
      {
        label: "WiFi ON (mA)",
        data: [90, 150, 220],
        borderColor: "#ef4444",
      },
      {
        label: "WiFi OFF (mA)",
        data: [50, 75, 100],
        borderColor: "#3b82f6",
      }
    ]
  }}
/>

## Light Sleep Mode

Light Sleep maintains full RAM state and can wake via timer or GPIO:

```cpp
#include "esp_sleep.h"

void enter_light_sleep(uint64_t sleep_us) {
    // Configure wake-up source
    esp_sleep_enable_timer_wakeup(sleep_us);
    
    // Enter light sleep
    esp_light_sleep_start();
    
    // Execution resumes here after wake-up
    // All RAM and registers preserved
}

void light_sleep_example() {
    // Sleep for 1 second
    enter_light_sleep(1000000);
    
    // Variables are still intact
    static int counter = 0;
    counter++;
}
```

**Measured current**: 0.8-1.2 mA (depending on RTC peripherals enabled)

<Callout type="info" title="Light Sleep Use Cases">
  Light sleep is ideal for applications that need to wake frequently (< 1 second) while maintaining state. Perfect for sensor polling with short intervals.
</Callout>

## Deep Sleep Mode

Deep Sleep powers down most of the chip, retaining only RTC memory:

```cpp
#include "esp_sleep.h"
#include "driver/rtc_io.h"

RTC_DATA_ATTR int boot_count = 0;

void deep_sleep_example() {
    boot_count++;
    
    // Save data to RTC memory (8 KB available)
    RTC_DATA_ATTR float sensor_data[100];
    // ... populate sensor_data ...
    
    // Configure wake-up
    esp_sleep_enable_timer_wakeup(10 * 1000000); // 10 seconds
    
    // Optional: Enable GPIO wake-up
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_0, 0); // Button on GPIO 0
    
    // Enter deep sleep
    esp_deep_sleep_start();
    // Code never reaches here - chip reboots after wake
}

void setup() {
    Serial.begin(115200);
    
    // Check wake reason
    esp_sleep_wakeup_cause_t cause = esp_sleep_get_wakeup_cause();
    
    switch(cause) {
        case ESP_SLEEP_WAKEUP_EXT0:
            Serial.println("Woke from GPIO");
            break;
        case ESP_SLEEP_WAKEUP_TIMER:
            Serial.println("Woke from timer");
            break;
        default:
            Serial.println("First boot");
    }
    
    Serial.printf("Boot count: %d\n", boot_count);
}
```

**Measured current**: 10-150 µA (varies based on RTC memory retention and peripherals)

## Optimizing Deep Sleep Current

Achieving low deep sleep current requires careful configuration:

```cpp
void optimize_deep_sleep() {
    // 1. Disable WiFi and Bluetooth
    WiFi.mode(WIFI_OFF);
    btStop();
    
    // 2. Disable ADC to prevent leakage
    adc_power_off();
    
    // 3. Configure RTC GPIOs properly
    // Floating pins can cause leakage
    for (int i = 0; i < 40; i++) {
        if (i != GPIO_NUM_0) { // Keep GPIO 0 for wake-up
            pinMode(i, INPUT_PULLUP); // or INPUT_PULLDOWN
        }
    }
    
    // 4. Minimize RTC memory usage
    // Only use RTC_DATA_ATTR for essential data
    
    // 5. Use RTC slow memory instead of fast memory
    // RTC slow memory: ~2 µA retention
    // RTC fast memory: ~500 µA retention
}
```

## Battery Life Calculation

For a 2000 mAh battery:

<Benchmark
  title="Battery Life Estimates (2000 mAh)"
  columns={["Mode", "Current", "Battery Life"]}
  rows={[
    { values: ["Active (240 MHz)", "200 mA", "10 hours"], highlight: false },
    { values: ["Modem Sleep", "25 mA", "80 hours"], highlight: false },
    { values: ["Light Sleep", "1 mA", "2000 hours (83 days)"], highlight: true },
    { values: ["Deep Sleep (optimized)", "15 µA", "133,333 hours (15 years)"], highlight: true },
  ]}
/>

## Practical Example: Sensor Node

A typical sensor node pattern:

```cpp
RTC_DATA_ATTR int measurement_count = 0;

void setup() {
    // Initialize sensors
    // Take measurement
    float temperature = read_temperature();
    float humidity = read_humidity();
    
    // Store in RTC memory (limited to 8 KB)
    RTC_DATA_ATTR float temps[100];
    RTC_DATA_ATTR float humids[100];
    
    temps[measurement_count % 100] = temperature;
    humids[measurement_count % 100] = humidity;
    measurement_count++;
    
    // Transmit data if buffer full or on schedule
    if (measurement_count % 100 == 0) {
        WiFi.begin("SSID", "password");
        // ... transmit data ...
        WiFi.disconnect();
    }
    
    // Sleep for 1 hour
    esp_sleep_enable_timer_wakeup(3600 * 1000000);
    esp_deep_sleep_start();
}
```

**Power profile**:
- Active (measurement + transmit): 200 mA × 2 seconds = 400 mAs
- Deep sleep: 15 µA × 3598 seconds = 54 mAs
- **Average current**: ~127 µA
- **Battery life**: ~1.6 years on 2000 mAh battery

## Conclusion

ESP32 power management requires understanding the trade-offs:

1. **Active mode**: Maximum functionality, maximum power
2. **Light sleep**: Fast wake-up, moderate power savings
3. **Deep sleep**: Maximum power savings, slower wake-up, limited state retention

Choose the mode that matches your application's wake frequency and state requirements.
