---
title: "ESP32 ULP Coprocessor Optimization: Ultra-Low-Power Sensor Processing"
author: "stanley-phoong"
description: "Advanced techniques for optimizing ESP32 ULP coprocessor code, minimizing power consumption while maintaining sensor processing capabilities during deep sleep."
publishDate: 2020-03-10
category: microcontrollers
tags: [esp32, ulp, coprocessor, low-power, optimization, embedded]
difficulty: expert
readingTime: 20
---

import Callout from '@/components/mdx/Callout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

The ESP32 ULP (Ultra Low Power) coprocessor enables sensor processing during deep sleep at ~150 µA. Optimizing ULP code is critical for battery-powered applications.

## ULP Architecture

ULP coprocessor specifications:

<Benchmark
  title="ESP32 ULP Specifications"
  columns={["Property", "Value", "Notes"]}
  rows={[
    { values: ["CPU", "RISC-V", "32-bit"], highlight: false },
    { values: ["Frequency", "8 MHz", "Fixed"], highlight: true },
    { values: ["Memory", "8 KB RTC Fast", "Code + Data"], highlight: true },
    { values: ["Power", "~150 µA", "During deep sleep"], highlight: true },
    { values: ["Wake Capability", "Yes", "Can wake main CPU"], highlight: false },
  ]}
/>

## ULP Programming

Write ULP code in assembly:

```c
#include "ulp_riscv.h"

// ULP program: read ADC and wake if threshold exceeded
const ulp_insn_t ulp_program[] = {
    // Load ADC channel
    I_MOVI(R0, 0),              // R0 = ADC channel 0
    
    // Read ADC
    I_ADC(R1, R0, 0),           // R1 = ADC reading
    
    // Compare with threshold (stored in RTC memory)
    I_LD(R2, R3, 0),            // R2 = threshold (from RTC memory)
    I_SUB(R3, R1, R2),          // R3 = reading - threshold
    
    // Branch: if reading > threshold, wake main CPU
    I_BGE(R3, 0, 2),            // If R3 >= 0, jump to wake
    I_HALT(),                   // Otherwise halt
    
    // Wake main CPU
    I_WAKE(),                   // Wake main CPU
    I_HALT(),                   // Halt ULP
};

// Load and run ULP program
void setup_ulp(void) {
    size_t size = sizeof(ulp_program) / sizeof(ulp_insn_t);
    ulp_process_macros_and_load(0, ulp_program, &size);
    ulp_run(0);
}
```

## Power Optimization

Minimize ULP power consumption:

```c
// Optimized ULP: minimize instructions
const ulp_insn_t optimized_ulp[] = {
    // Read ADC (minimal instructions)
    I_MOVI(R0, 0),
    I_ADC(R1, R0, 0),
    
    // Quick threshold check
    I_LD(R2, R3, 0),            // Threshold
    I_SUB(R3, R1, R2),
    I_BL(R3, 0, 2),             // Branch if below threshold
    
    // Wake only if needed
    I_WAKE(),
    I_HALT(),
};

// Power consumption: ~150 µA (minimal)
```

**Optimization**: Reduce instruction count to minimize execution time

## Sensor Sampling Optimization

Efficient sensor sampling:

```c
// Sample sensor every 1 second
const ulp_insn_t sensor_sampling[] = {
    // Initialize counter
    I_MOVI(R0, 0),              // R0 = sample counter
    
    // Main loop
    I_LABEL(1),
    
    // Read sensor
    I_MOVI(R1, 0),              // ADC channel
    I_ADC(R2, R1, 0),           // R2 = reading
    
    // Store in RTC memory
    I_ST(R2, R0, 0),            // Store at address R0
    
    // Increment counter
    I_ADDI(R0, R0, 1),          // R0++
    
    // Check if buffer full
    I_MOVI(R3, 100),            // Buffer size
    I_SUB(R3, R0, R3),          // R3 = counter - size
    I_BGE(R3, 0, 2),            // If full, wake CPU
    
    // Wait 1 second (8 MHz / 1000 = 8000 cycles)
    I_DELAY(8000),
    
    I_JMP(1),                   // Loop
    
    // Wake CPU when buffer full
    I_WAKE(),
    I_HALT(),
};
```

## Memory Management

Optimize RTC memory usage:

```c
// Store sensor data efficiently
RTC_DATA_ATTR uint16_t sensor_buffer[50];
RTC_DATA_ATTR uint8_t buffer_index = 0;

// ULP stores data, main CPU processes
void ulp_store_sample(uint16_t sample) {
    // ULP stores directly to RTC memory
    // No CPU intervention needed
}
```

**Memory efficiency**: Direct RTC memory access, no copying

## Performance Analysis

ULP vs main CPU power:

<Benchmark
  title="Power Consumption Comparison"
  columns={["Method", "Current", "Processing Rate", "Energy per Sample"]}
  rows={[
    { values: ["Main CPU (240 MHz)", "100 mA", "1000 samples/s", "100 µJ"], highlight: false },
    { values: ["Main CPU (80 MHz)", "50 mA", "333 samples/s", "150 µJ"], highlight: false },
    { values: ["ULP", "150 µA", "8 samples/s", "18.75 µJ"], highlight: true },
  ]}
/>

<PerfChart
  title="Power vs Processing Rate"
  type="scatter"
  data={{
    datasets: [
      {
        label: "Main CPU 240 MHz",
        data: [{x: 1000, y: 100}],
        backgroundColor: "#ef4444",
      },
      {
        label: "Main CPU 80 MHz",
        data: [{x: 333, y: 50}],
        backgroundColor: "#f59e0b",
      },
      {
        label: "ULP",
        data: [{x: 8, y: 0.15}],
        backgroundColor: "#10b981",
      }
    ]
  }}
/>

## Optimization Strategies

1. **Minimize instructions**: Reduce execution time
2. **Efficient sampling**: Sample only when needed
3. **Direct RTC access**: Avoid copying data
4. **Conditional wake**: Wake only on events
5. **Optimize loops**: Reduce loop overhead

## Conclusion

ULP optimization provides:

1. **Ultra-low power**: ~150 µA during deep sleep
2. **Sensor processing**: Continuous monitoring
3. **Selective wake**: Wake only on events
4. **Memory efficiency**: Direct RTC access
5. **Battery life**: Years of operation

Key strategies:
- Minimize instruction count
- Sample sensors efficiently
- Use conditional wake
- Optimize memory access
- Balance sampling rate and power

Master ULP optimization for ultra-low-power sensor applications.
