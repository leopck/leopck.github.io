---
title: "ESP32 SPI + DMA: Hitting the Practical Throughput Ceiling"
author: "stanley-phoong"
description: "A performance-oriented guide to ESP32 SPI with DMA: clock configuration, burst sizing, FIFO/DMA interaction, and how to measure and approach the real-world throughput limit with logic-analyzer-verified timing."
publishDate: 2020-09-22
category: microcontrollers
tags: [esp32, spi, dma, throughput, optimization, embedded, performance]
difficulty: advanced
readingTime: 18
---

import Callout from '@/components/mdx/Callout.astro';
import PerfChart from '@/components/mdx/PerfChart.astro';
import Benchmark from '@/components/mdx/Benchmark.astro';

ESP32’s SPI peripherals can clock well into the tens of MHz, but getting there in practice requires:
- the right clock tree configuration
- DMA instead of CPU-driven transfers
- bursts large enough to amortize overhead

This post shows how to approach the **practical** SPI throughput limit for streaming sensors or displays.

## Theoretical vs practical bandwidth

Theoretical one-direction bandwidth:
\[
BW_{theoretical} = f_{spi} \cdot \frac{bits\_per\_transfer}{bits\_per\_symbol}
\]

At 40 MHz, 8 bits/transfer:
\[
BW \approx 40 \text{ Mbit/s} \approx 5 \text{ MB/s}
\]

In practice, inter-byte gaps, chip-select handling, and software overhead bring this down.

<Benchmark
  title="Example: measured vs theoretical (one-way)"
  columns={["Clock", "Theoretical MB/s", "Measured MB/s", "Efficiency"]}
  rows={[
    { values: ["10 MHz", "1.25", "1.10", "88%"], highlight: true },
    { values: ["20 MHz", "2.50", "2.05", "82%"], highlight: false },
    { values: ["40 MHz", "5.00", "3.70", "74%"], highlight: false },
  ]}
/>

## ESP32 SPI master + DMA setup (sketch)

```cpp
#include "driver/spi_master.h"

spi_device_handle_t spi_dev;

void spi_init(int mosi, int miso, int sclk, int cs, int hz) {
  spi_bus_config_t buscfg = {
    .mosi_io_num = mosi,
    .miso_io_num = miso,
    .sclk_io_num = sclk,
    .quadwp_io_num = -1,
    .quadhd_io_num = -1,
    .max_transfer_sz = 4096,
  };
  spi_bus_initialize(HSPI_HOST, &buscfg, SPI_DMA_CH_AUTO);

  spi_device_interface_config_t devcfg = {
    .clock_speed_hz = hz,
    .mode = 0,
    .spics_io_num = cs,
    .queue_size = 4,
    .flags = SPI_DEVICE_HALFDUPLEX,
  };
  spi_bus_add_device(HSPI_HOST, &devcfg, &spi_dev);
}
```

## DMA burst transfers

```cpp
static uint8_t tx_buf[4096];

size_t spi_dma_transfer(const uint8_t* data, size_t len) {
  spi_transaction_t t = {};
  t.length = len * 8;
  t.tx_buffer = data;
  spi_device_transmit(spi_dev, &t);  // blocking, uses DMA under the hood
  return len;
}
```

For sustained streaming, use `spi_device_queue_trans` + `spi_device_get_trans_result` to pipeline transfers.

## Burst sizing: amortizing CS and setup overhead

Small bursts:
- suffer from CS toggling & command overhead
- more host calls per byte

Larger bursts:
- better efficiency
- more latency (buffering)

<PerfChart
  title="Throughput vs burst size (example @ 20 MHz)"
  type="line"
  data={{
    labels: ["16", "64", "256", "1024", "4096"],
    datasets: [{
      label: "MB/s",
      data: [0.6, 1.3, 1.9, 2.1, 2.1],
      borderColor: "#3b82f6",
    }]
  }}
/>

## Measuring throughput correctly

Use both:
- `esp_timer_get_time()` around transfers
- logic analyzer on SCLK/CS to see actual bus utilization

```cpp
uint64_t t0 = esp_timer_get_time();
for (int i = 0; i < iters; i++) {
  spi_dma_transfer(tx_buf, burst_bytes);
}
uint64_t dt = esp_timer_get_time() - t0;

double total_bytes = (double)iters * burst_bytes;
double mbps = total_bytes / (dt / 1e6) / (1024.0 * 1024.0);
```

## Optimization tips

- Put SPI on the **fastest host** (HSPI/VSPI)
- Use **DMA** with large bursts for sustained streams
- Avoid per-byte APIs (send in blocks)
- Tune clock upward until signal integrity errors appear, then back off
- Minimize time between queued transactions

<Callout type="warning" title="Signal integrity caps clock">
  Above ~26–40 MHz (board dependent), trace length, impedance, and load dominate. Use a scope/logic analyzer — not just benchmarks — when pushing the top end.
</Callout>

## Conclusion

With DMA and proper burst sizing, ESP32 SPI can get close to its theoretical limit for real workloads, while keeping CPU load low enough to run non-trivial processing in parallel.

