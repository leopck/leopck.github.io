
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minimal Bare Metal Bootloader - Fridays with Faraday</title>
  <meta name="description" content="**ARM Cortex-M4** • **Bootloader** • **Assembly**">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="alternate" type="application/rss+xml" title="Fridays with Faraday" href="../rss.xml">
</head>
<body>
  <div class="background"></div>
  <div class="grid-overlay"></div>

  
<nav>
  <div class="container">
    <a href="/" class="logo">
      <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
    </a>
    <ul class="nav-menu">
      <li><a href="/#work">Work</a></li>
      <li><a href="/experiments.html" class="active">Experiments</a></li>
      <li><a href="/search.html">Search</a></li>
      <li><a href="mailto:your.email@example.com">Contact</a></li>
    </ul>
    <button class="nav-toggle" aria-label="Toggle menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
  </div>
</nav>

  
<section class="experiment-header">
  <div class="container">
    <h1 class="experiment-title">Minimal Bare Metal Bootloader</h1>
    <div class="experiment-meta">
      <span class="tag">experiments</span>
      
      <span class="tag difficulty-intermediate">intermediate</span>
    </div>
    <div class="post-meta">
      <span class="meta-item">
        <strong>Date:</strong> 11/2/2025
      </span>
      <span class="meta-item">
        <strong>Read Time:</strong> undefined
      </span>
      <span class="meta-item">
        <strong>Author:</strong> 
      </span>
    </div>
    <p class="post-description">**ARM Cortex-M4** • **Bootloader** • **Assembly**</p>
  </div>
</section>

<section>
  <div class="container">
    <div class="content-layout">
      <main class="content-main">
        
    <div class="toc">
      <h3>Table of Contents</h3>
      <nav class="toc-nav">
        <a href="#minimal-bare-metal-bootloader" class="toc-link toc-level-1">
            Minimal Bare Metal Bootloader
          </a>
        <a href="#results" class="toc-link toc-level-2">
              Results
          </a>
        <a href="#why-write-a-bootloader" class="toc-link toc-level-2">
              Why Write a Bootloader?
          </a>
        <a href="#memory-layout" class="toc-link toc-level-2">
              Memory Layout
          </a>
        <a href="#the-linker-script" class="toc-link toc-level-2">
              The Linker Script
          </a>
        <a href="#startup-code" class="toc-link toc-level-2">
              Startup Code
          </a>
        <a href="#bootloader-logic" class="toc-link toc-level-2">
              Bootloader Logic
          </a>
        <a href="#firmware-update-protocol" class="toc-link toc-level-2">
              Firmware Update Protocol
          </a>
        <a href="#building-and-flashing" class="toc-link toc-level-2">
              Building and Flashing
          </a>
        <a href="#testing-the-bootloader" class="toc-link toc-level-2">
              Testing the Bootloader
          </a>
        <a href="#what-i-learned" class="toc-link toc-level-2">
              What I Learned
          </a>
      </nav>
    </div>
  
        <div class="post-content">
          <p><h1 id="minimal-bare-metal-bootloader">Minimal Bare Metal Bootloader</h1></p><p><strong>ARM Cortex-M4<em>* • **Bootloader** • *</em>Assembly</strong></p><p>Writing a minimal bootloader from scratch without vendor HAL libraries. Just startup assembly, a linker script, and some C code. The goal was to understand what actually happens before main() runs.</p><p><h2 id="results">Results</h2></p><p><tr><td>Metric</td><td>Value</td></tr>
<tr><td>--------</td><td>-------</td></tr>
<tr><td>Binary Size</td><td><strong>2KB</strong></td></tr>
<tr><td>Boot Time</td><td><strong>50ms</strong></td></tr>
<tr><td>Flash Reserved</td><td><strong>8KB</strong></td></tr>
<tr><td>Success Rate</td><td><strong>100%</strong></td></tr></p><p><h2 id="why-write-a-bootloader">Why Write a Bootloader?</h2></p><p>I wanted to implement field firmware updates over UART without an external programmer. Commercial bootloaders exist, but building one yourself teaches you exactly what happens during MCU startup, how the vector table works, and how to manage multiple firmware images in flash.</p><p>Target: STM32F407VG, 1MB flash, 192KB RAM. The bootloader occupies the first 8KB, application starts at 0x08002000.</p><p><h2 id="memory-layout">Memory Layout</h2></p><p>The flash is divided into bootloader and application sections:</p><p><div class="code-block"><pre><code class="language-text">0x08000000 - 0x08001FFF (8KB)  : Bootloader
0x08002000 - 0x080FFFFF (1016KB): Application
0x20000000 - 0x2002FFFF (192KB) : RAM</code></pre></div></p><p><h2 id="the-linker-script">The Linker Script</h2></p><p>First, define the memory regions and sections. This tells the compiler where everything goes.</p><p><div class="code-block"><pre><code class="language-c">/<em> bootloader.ld </em>/
MEMORY
{
    FLASH (rx)  : ORIGIN = 0x08000000, LENGTH = 8K
    RAM (rwx)   : ORIGIN = 0x20000000, LENGTH = 192K
}</p><p>_estack = ORIGIN(RAM) + LENGTH(RAM);  /<em> Top of stack </em>/</p><p>SECTIONS
{
    /<em> Vector table must be at the start of flash </em>/
    .isr_vector :
    {
        . = ALIGN(4);
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } &gt;FLASH</p><p>    /<em> Code section </em>/
    .text :
    {
        . = ALIGN(4);
        *(.text)
        <em>(.text</em>)
        *(.rodata)
        <em>(.rodata</em>)
        . = ALIGN(4);
    } &gt;FLASH</p><p>    /<em> Initialized data (copied from flash to RAM at startup) </em>/
    .data :
    {
        . = ALIGN(4);
        _sdata = .;
        *(.data)
        <em>(.data</em>)
        . = ALIGN(4);
        _edata = .;
    } &gt;RAM AT&gt;FLASH</p><p>    /<em> Uninitialized data (zeroed at startup) </em>/
    .bss :
    {
        . = ALIGN(4);
        _sbss = .;
        *(.bss)
        <em>(.bss</em>)
        *(COMMON)
        . = ALIGN(4);
        _ebss = .;
    } &gt;RAM
}</code></pre></div></p><p><h2 id="startup-code">Startup Code</h2></p><p>The startup assembly initializes the stack, copies .data from flash to RAM, zeros .bss, and jumps to main().</p><p><div class="code-block"><pre><code class="language-assembly">/<em> startup.s - ARM Cortex-M4 startup </em>/
.syntax unified
.cpu cortex-m4
.thumb</p><p>/<em> Vector table </em>/
.section .isr_vector,&quot;a&quot;
.word _estack              /<em> Initial stack pointer </em>/
.word Reset_Handler        /<em> Reset handler </em>/
.word NMI_Handler
.word HardFault_Handler
/<em> ... more exception vectors ... </em>/</p><p>/<em> Reset handler - executed on startup </em>/
.section .text.Reset_Handler
.weak Reset_Handler
.type Reset_Handler, %function
Reset_Handler:
    /<em> Copy .data from flash to RAM </em>/
    ldr r0, =_sdata        /<em> Start of .data in RAM </em>/
    ldr r1, =_edata        /<em> End of .data in RAM </em>/
    ldr r2, =_sidata       /<em> Start of .data in flash </em>/
    movs r3, #0
    b copy_data_check</p><p>copy_data_loop:
    ldr r4, [r2, r3]       /<em> Read from flash </em>/
    str r4, [r0, r3]       /<em> Write to RAM </em>/
    adds r3, r3, #4</p><p>copy_data_check:
    adds r4, r0, r3
    cmp r4, r1
    bcc copy_data_loop</p><p>    /<em> Zero .bss section </em>/
    ldr r2, =_sbss
    ldr r4, =_ebss
    movs r3, #0
    b zero_bss_check</p><p>zero_bss_loop:
    str r3, [r2]
    adds r2, r2, #4</p><p>zero_bss_check:
    cmp r2, r4
    bcc zero_bss_loop</p><p>    /<em> Call main() </em>/
    bl main
    bx lr</p><p>/<em> Default exception handlers </em>/
.weak NMI_Handler
.thumb_set NMI_Handler,Default_Handler</p><p>.weak HardFault_Handler
.thumb_set HardFault_Handler,Default_Handler</p><p>Default_Handler:
    b Default_Handler</code></pre></div></p><p><h2 id="bootloader-logic">Bootloader Logic</h2></p><p>The main bootloader code checks for a valid application and jumps to it, or enters update mode if requested.</p><p><div class="code-block"><pre><code class="language-c">#include &lt;stdint.h&gt;</p><p>#define APP_START_ADDR    0x08002000
#define BOOT_FLAG_ADDR    0x2001FFF0  /<em> Magic value in RAM </em>/
#define BOOT_FLAG_UPDATE  0xDEADBEEF</p><p>typedef void (*app_fn)(void);</p><p>static int is_app_valid(uint32_t app_addr) {
    /<em> Check if stack pointer is in RAM </em>/
    uint32_t sp = <em>((__IO uint32_t</em>)app_addr);
    if (sp &lt; 0x20000000 || sp &gt; 0x20030000) {
        return 0;
    }
    
    /<em> Check if reset vector points to flash </em>/
    uint32_t reset = <em>((__IO uint32_t</em>)(app_addr + 4));
    if (reset &lt; 0x08000000 || reset &gt; 0x08100000) {
        return 0;
    }
    
    return 1;
}</p><p>static void jump_to_app(uint32_t app_addr) {
    /<em> Get application stack pointer and reset handler </em>/
    uint32_t app_sp = <em>((__IO uint32_t</em>)app_addr);
    uint32_t app_reset = <em>((__IO uint32_t</em>)(app_addr + 4));
    
    /<em> Disable all interrupts </em>/
    __disable_irq();
    
    /<em> Relocate vector table to application </em>/
    SCB-&gt;VTOR = app_addr;
    
    /<em> Set stack pointer </em>/
    __set_MSP(app_sp);
    
    /<em> Jump to application reset handler </em>/
    app_fn app = (app_fn)app_reset;
    app();
    
    /<em> Should never reach here </em>/
    while(1);
}</p><p>int main(void) {
    /<em> Check if firmware update requested </em>/
    volatile uint32_t<em> boot_flag = (uint32_t</em>)BOOT_FLAG_ADDR;
    
    if (*boot_flag == BOOT_FLAG_UPDATE) {
        <em>boot_flag = 0;  /* Clear flag </em>/
        
        /<em> Enter firmware update mode </em>/
        uart_init();
        firmware_update_mode();
    }
    
    /<em> Try to boot application </em>/
    if (is_app_valid(APP_START_ADDR)) {
        jump_to_app(APP_START_ADDR);
    }
    
    /<em> No valid app - enter recovery mode </em>/
    uart_init();
    recovery_mode();
    
    while(1);
}</code></pre></div></p><p><h2 id="firmware-update-protocol">Firmware Update Protocol</h2></p><p>Simple UART protocol for receiving new firmware over serial:</p><p><div class="code-block"><pre><code class="language-c">void firmware_update_mode(void) {
    uart_puts(&quot;Bootloader v1.0\r\n&quot;);
    uart_puts(&quot;Ready for firmware update\r\n&quot;);
    
    uint32_t addr = APP_START_ADDR;
    uint32_t bytes_received = 0;
    
    /<em> Erase application flash </em>/
    flash_erase(APP_START_ADDR, 1016 * 1024);
    
    while(1) {
        /<em> Simple protocol: [CMD][LEN][DATA][CRC] </em>/
        uint8_t cmd = uart_getc();
        
        if (cmd == 0x01) {  /<em> Write data </em>/
            uint16_t len = uart_get_u16();
            uint8_t data[256];
            
            for (int i = 0; i &lt; len; i++) {
                data[i] = uart_getc();
            }
            
            uint16_t crc = uart_get_u16();
            if (crc == calc_crc16(data, len)) {
                flash_write(addr, data, len);
                addr += len;
                bytes_received += len;
                uart_putc(0x06);  /<em> ACK </em>/
            } else {
                uart_putc(0x15);  /<em> NAK </em>/
            }
        }
        else if (cmd == 0x02) {  /<em> Finish </em>/
            if (is_app_valid(APP_START_ADDR)) {
                uart_puts(&quot;Update complete\r\n&quot;);
                jump_to_app(APP_START_ADDR);
            } else {
                uart_puts(&quot;Invalid firmware\r\n&quot;);
            }
        }
    }
}</code></pre></div></p><p><h2 id="building-and-flashing">Building and Flashing</h2></p><p>Compile with ARM GCC and flash using st-link:</p><p>
<div class="terminal">
  <div class="terminal-header">
    <div class="terminal-dot" style="background: #ff5f56;"></div>
    <div class="terminal-dot" style="background: #ffbd2e;"></div>
    <div class="terminal-dot" style="background: #27c93f;"></div>
  </div>
  <div class="terminal-content">
    <pre><code>$ arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -c startup.s
$ arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -c main.c uart.c flash.c
$ arm-none-eabi-gcc -T bootloader.ld *.o -o bootloader.elf -nostdlib
$ arm-none-eabi-objcopy -O binary bootloader.elf bootloader.bin</p><p>$ ls -lh bootloader.bin
-rw-r--r-- 1 user user 2.1K Jan 15 10:23 bootloader.bin</p><p>$ st-flash write bootloader.bin 0x8000000
st-flash 1.7.0
2024-01-15T10:23:45 INFO common.c: Loading device parameters....
2024-01-15T10:23:45 INFO common.c: Device connected is: F4 device, id 0x10076413
2024-01-15T10:23:46 INFO common.c: Flash written and verified!</code></pre>
  </div>
</div></p><p><h2 id="testing-the-bootloader">Testing the Bootloader</h2></p><p>Power cycle and observe boot sequence:</p><p><div class="code-block"><pre><code class="language-text">$ minicom -D /dev/ttyUSB0 -b 115200
[Power cycle]</p><p>Bootloader v1.0
Checking application at 0x08002000...
Valid application found
Jumping to application in 50ms...</p><p>Application v2.3
System initialized</code></pre></div></p><p><h2 id="what-i-learned">What I Learned</h2></p><p>• The vector table MUST be the first thing in flash - CPU reads initial SP and reset handler from 0x0.  
• Linker scripts are powerful but cryptic - understanding them is essential for embedded work.  
• Always validate the application before jumping - check SP and reset vector point to valid memory.  
• The VTOR (Vector Table Offset Register) needs to be updated when relocating to the app.  
• Stack pointer must be set manually before jumping to application.  
• A simple CRC check prevents bricking the device with corrupted firmware.  
• Testing on real hardware revealed timing issues not visible in simulation.
</p>
        </div>
        
    <div class="related-posts">
      <h3>Related Posts</h3>
      <div class="related-grid">
        
          <a href="../experiments/esp32-low-power.html" class="related-card">
            <h4>Getting ESP32 to 12µA Sleep Current</h4>
            <p>**Tags:** ESP32 • Low Power • Deep Sleep</p>
            <span class="tag">experiments</span>
          </a>
        
          <a href="../experiments/stm32-dma.html" class="related-card">
            <h4>High-Speed ADC with DMA</h4>
            <p>**STM32F4** **DMA** **ADC**</p>
            <span class="tag">experiments</span>
          </a>
        
          <a href="../experiments/esp32-adc-performance.html" class="related-card">
            <h4>ESP32 High-Speed ADC Performance: DMA and Interrupt Analysis</h4>
            <p>High-speed analog-to-digital conversion on microcontrollers often becomes CPU-bound long before hitting the advertised sampling rates. The ESP32 integrates two successive approximation register (SAR) </p>
            <span class="tag">experiments</span>
          </a>
        
      </div>
    </div>
  
      </main>
    </div>
  </div>
</section>

  <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border);">
    <div class="container">
      <a href="../experiments.html" style="color: var(--accent); text-decoration: none;">← Back to all experiments</a>
    </div>
  </div>

  
<footer>
  <div class="container">
    <div class="footer-content">
      <div class="footer-logo">
        <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
      </div>
      <p>Fridays with Faraday - Working with microcontrollers and embedded systems</p>
      <div class="footer-links">
        <a href="/rss.xml">RSS Feed</a>
        <a href="https://github.com/yourusername/yourusername.github.io">GitHub</a>
      </div>
    </div>
  </div>
</footer>

  <script src="../js/main.js"></script>
</body>
</html>