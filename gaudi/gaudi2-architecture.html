<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaudi2 Architecture Deep Dive for AI Workloads - Fridays with Faraday</title>
    <meta name="description" content="Intel’s Gaudi2 is a second-generation AI training accelerator built around a deliberate separation of concerns: a configurable Matrix Multiplication Engine (MME) optimized for GEMMs and convolutions, ">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div class="background"></div>
    <div class="grid-overlay"></div>

    
<nav>
  <div class="container">
    <a href="/" class="logo">
      <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
    </a>
    <ul class="nav-menu">
      <li><a href="/#work">Work</a></li>
      <li><a href="/experiments.html" class="active">Experiments</a></li>
      <li><a href="mailto:your.email@example.com">Contact</a></li>
    </ul>
    <button class="nav-toggle" aria-label="Toggle menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
  </div>
</nav>

        <section class="experiment-header">
        <div class="container">
            <h1 class="experiment-title">Gaudi2 Architecture Deep Dive for AI Workloads</h1>
            
            <p style="color: var(--text-secondary); font-size: 1.1rem; max-width: 800px;">
                Intel’s Gaudi2 is a second-generation AI training accelerator built around a deliberate separation of concerns: a configurable Matrix Multiplication Engine (MME) optimized for GEMMs and convolutions, 
            </p>
        </div>
    </section>

    <section>
        <div class="container">
            <div class="content-section">
                <p><h1>Gaudi2 Architecture Deep Dive for AI Workloads</h1></p><p><h2>Executive Summary: What Gaudi2 Is and Why It Matters</h2></p><p>Intel’s Gaudi2 is a second-generation AI training accelerator built around a deliberate separation of concerns: a configurable Matrix Multiplication Engine (MME) optimized for GEMMs and convolutions, and a programmable Tensor Processor Core (TPC) for everything else. The result is a system architected for throughput, scalability, and predictable behavior under production workloads, rather than a monolithic, general-purpose shader array. The design choice matters because it aligns hardware data paths, control primitives, and memory hierarchy tightly with the real bottlenecks in deep learning training: matrix arithmetic, data movement, and interconnects for scale-out.</p><p>In practical terms, Gaudi2 pairs a high-capacity, high-bandwidth memory subsystem (96 GB HBM2e at roughly 2.45 TB/s, plus 48 MB of on-die SRAM) with an integrated, scale-out Ethernet networking fabric (24 ports of 100 Gbps RoCE v2) to deliver both device-level and cluster-level efficiency. This dual-path approach—compute specialization plus integrated networking—reduces dependence on external NICs for scale-up/scale-out and provides deterministic paths for collective communications in large clusters[^1].</p><p>At the die level, compute is clustered into Deep Learning Cores (DCOREs), each containing 2x MME, 16x TPC, and a 24 MB cache. The MMEs employ a large, output-stationary systolic array (256x256 MAC structure) with FP32 accumulators and integrated address generation units (AGUs), while the TPCs use a VLIW SIMD architecture with four slots (Vector, Scalar, Load, Store) and their own AGUs to drive efficient, strided, and tensor-shaped data movement. The memory hierarchy is unified at the L2/L3/HBM level, with explicit cache directives (No-$, L2$, L3$, L2$+L3$) and Memory Context ID (MCID) mechanisms that allow software to steer cache policy and residency for different algorithmic phases[^4][^5].</p><p>To ground the discussion, Figure 1 shows the Gaudi3 architecture (used as a conceptual proxy for Gaudi2’s organization), with DCOREs, the control path, and the networking fabric. The same clustering and control primitives apply to Gaudi2, which shares the overall architectural philosophy while differing in generation-specific specs (e.g., HBM capacity, SRAM, PCIe generation, and NIC bandwidth).</p><p>!<a href=".pdf_temp/viewrange_chunk_1_1_5_1762065676/images/x5a5xi.jpg">Gaudi high-level block diagram (used as architectural context)</a></p><p>Table 1 summarizes Gaudi2’s salient specifications most relevant to system performance analysis. The figures contextualize the hardware’s ability to sustain high-throughput training and inference, and they frame the bottlenecks we will examine in later sections.</p><p>Table 1: Gaudi2 key specifications and implications</p><p><tr><td>Specification</td><td>Gaudi2 Value</td><td>Practical Implication</td></tr>
<tr><td>---</td><td>---</td><td>---</td></tr>
<tr><td>HBM2e Capacity</td><td>96 GB</td><td>Larger per-device model or batch capacity; fewer devices required for a given model size[^1]</td></tr>
<tr><td>HBM2e Bandwidth</td><td>~2.45 TB/s</td><td>Sustained read/write rates for GEMMs and activations; informs tensor shape and batch sizing[^1]</td></tr>
<tr><td>On-die SRAM</td><td>48 MB</td><td>Fast scratch for tiling, transposes, and partials; mitigates HBM pressure[^1]</td></tr>
<tr><td>Embedded NIC</td><td>24x 100 GbE RoCE v2 (≈4.8 Tb/s bidirectional)</td><td>Integrated RDMA reduces hop count and improves all-reduce/collective cost at scale[^1]</td></tr>
<tr><td>Host Interface</td><td>PCIe Gen4 x16 (≈64 GB/s bidirectional)</td><td>Host–device transfer ceiling; implications for data loading, checkpointing[^3]</td></tr>
<tr><td>Media Engines</td><td>Integrated decoders (HEVC/H.264/JPEG/VP9)</td><td>Offloads pre-processing; reduces host CPU overhead[^1]</td></tr></p><p>In the sections that follow, we analyze the driver-level control path (Submission/Completion Queues, Sync Manager, Interrupt Manager), the register-level programming model (primarily via device configuration and TPC intrinsics), the memory hierarchy (HBM, SRAM, unified L2/L3, cache directives), and the networking subsystem (integrated RoCE v2). We then detail DMA and PCIe behaviors and touch on firmware-mediated engine synchronization and power/cooling form factors. Throughout, we draw on Gaudi3 architecture to explain mechanisms that generalize across generations where design intent is unchanged[^4][^5].</p><p>
<h2>System Overview and Logical Topology</h2></p><p>Gaudi2’s system-on-chip (SoC) is organized into four DCOREs. Each DCORE contains 2 MME engines, 16 TPC cores, and a 24 MB cache. This clustering is not merely a floorplanning convenience; it expresses an intentional locality principle: tensor cores and their working sets remain close to dedicated cache and near-memory compute, reducing cross-die traffic and easing synchronization at task boundaries[^4][^5].</p><p>The host interface is PCIe Gen4 x16, offering approximately 64 GB/s bidirectional bandwidth. While modern servers can saturate this link, workload characteristics (e.g., activation checkpointing, gradient accumulation, and host-side data loading) determine whether the PCIe path becomes the limiting factor. Gaudi2 integrates 24 100 Gbps RoCE v2 NIC ports directly on the accelerator die, providing both scale-up (card-to-card within a node) and scale-out (rack-to-rack) paths without requiring discrete host NICs for collectives. This architecture reduces latency and improves bandwidth predictability for inter-accelerator traffic[^1][^3].</p><p>!<a href=".pdf_temp/viewrange_chunk_2_6_10_1762065678/images/1e4znz.jpg">Gaudi3 baseboard/card topology reference (Gaudi2 shares networking concepts)</a></p><p>Table 2 lists the host interface and expected throughput across generations. The shift from PCIe Gen4 to Gen5 roughly doubles peak host bandwidth, but for Gaudi2, the Gen4 ceiling remains the operational constraint.</p><p>Table 2: Host interface comparison and practical throughput expectations</p><p><tr><td>Product Generation</td><td>PCIe Generation</td><td>Lanes</td><td>Peak Bidirectional Bandwidth</td><td>Observed/Expected Ranges</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Gaudi</td><td>Gen3</td><td>x16</td><td>~64 GB/s</td><td>Varies by platform; typically below peak due to overhead[^3]</td></tr>
<tr><td>Gaudi2</td><td>Gen4</td><td>x16</td><td>~64 GB/s</td><td>Near-peak feasible; dependent on CPU, BIOS, slot, and workload[^3]</td></tr>
<tr><td>Gaudi3</td><td>Gen5</td><td>x16</td><td>~128 GB/s</td><td>Higher ceilings; improved host–device pipelines[^3]</td></tr></p><p>Form factor matters for system design. Gaudi2 appears in OCP Accelerator Module (OAM) and PCIe CEM variants. The OAM path typically enables higher device power and a richer set of on-board networking ports, while the PCIe add-in card trades some networking flexibility for compactness and ease of integration in existing host platforms. Table 3 summarizes form factor and typical power envelopes[^3].</p><p>Table 3: Form factor and power characteristics</p><p><tr><td>Form Factor</td><td>Typical Use</td><td>Power Envelope (TDP)</td><td>Notes</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>OAM (e.g., HL-325L)</td><td>Server-grade baseboards with on-board scaling fabric</td><td>Up to 900 W (air), up to 900–1200 W (liquid depending on generation)</td><td>24x 100 GbE (Gaudi2) integrated NIC; card-to-card and scale-out[^3]</td></tr>
<tr><td>PCIe CEM (e.g., HL-338)</td><td>Add-in accelerator cards</td><td>Up to 600 W (passive)</td><td>Scale-up via top board; scale-out via host NIC[^3]</td></tr></p><p>The distinction is not academic. When building multi-device systems, topology influences both latency (fewer hops for device–device traffic) and throughput (more bisection bandwidth on-board). The baseboard’s physical layout governs whether the NIC fabric becomes the bottleneck or an enabler for model and data parallel strategies[^3].</p><p>
<h2>Compute Architecture: MME and TPC in Detail</h2></p><p>Gaudi2’s compute plane is intentionally bifurcated. The MME is a configurator’s arithmetic engine: you describe the operation and tensor shapes; the hardware performs the matrix multiply using a large, output-stationary systolic array with deeply pipelined dataflows. The TPC is the programmer’s arithmetic engine: a VLIW SIMD core with explicit vector, scalar, load, and store pipelines, augmented by AGUs and local memory for flexible, non-GEMM workloads.</p><p>The MME’s 256x256 MAC array, FP32 accumulators, and AGU-based address generation allow it to handle fully connected layers, convolutions, and batched GEMMs efficiently. Its integrated transpose engines remove a common source of overhead when reshaping activations, and its internal buffers serve as a functional L1 replacement by reusing inputs in-place. The TPC fills in everything else: element-wise ops, normalization layers, activations, reductions, and custom ops. The slot-based VLIW design (Vector, Scalar, Load, Store) ensures that, with careful scheduling, memory latency and bandwidth can be overlapped with compute[^4][^5].</p><p>!<a href=".pdf_temp/viewrange_chunk_2_6_10_1762065675/images/engwyx.jpg">MME block diagram: systolic array, pipelines, and AGU</a></p><p>!<a href=".pdf_temp/viewrange_chunk_2_6_10_1762065675/images/9trflq.jpg">TPC block diagram: VLIW pipelines, vector register file, and local memory</a></p><p>Table 4 compares the MME and TPC feature sets from a programmer’s perspective.</p><p>Table 4: Feature comparison — MME vs. TPC</p><p><tr><td>Feature</td><td>MME</td><td>TPC</td></tr>
<tr><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Role</td><td>GEMM/convolution engine</td><td>Programmable SIMD for non-GEMM ops</td></tr>
<tr><td>Programmability</td><td>Configurable via descriptors</td><td>Programmable in C with TPC intrinsics</td></tr>
<tr><td>Core Structure</td><td>256x256 systolic, output-stationary</td><td>VLIW with 4 slots (Vector, Scalar, Load, Store)</td></tr>
<tr><td>Accumulator Precision</td><td>FP32</td><td>FP and integer types supported by kernel</td></tr>
<tr><td>Data Types</td><td>BF16/FP8 MAC with FP32 accum; convert on write</td><td>1/2/4-byte FP and integer types</td></tr>
<tr><td>Address Generation</td><td>Integrated AGU for 5-D tensors, OOB handling</td><td>Load/Store slot AGUs for 5-D tensors</td></tr>
<tr><td>Local Memory</td><td>Internal buffers for input reuse</td><td>80 KB vector local memory (VLM)</td></tr>
<tr><td>Throughput Drivers</td><td>Transpose engines; parallel read/compute/write</td><td>Latency hiding; high-width vector lane</td></tr>
<tr><td>Typical Ops</td><td>Matmul, convolution, batched GEMM</td><td>Element-wise, reductions, norm, activations</td></tr></p><p><h3>MME Programming and Dataflows</h3></p><p>At register level, the MME is configured rather than programmed in microcode. The driver and firmware agree on a descriptor that defines tensor shapes, precision, strides, transpose flags, and boundary behaviors (e.g., out-of-bounds padding). The hardware’s systolic dataflow ensures that, once filled, the array produces output tiles with minimal stall and high reuse of on-chip data. A critical nuance is the AGU’s role in 5-D addressing: by offloading bounds checking and padding, the MME avoids special-casing in software and supports generic tensor layouts in compiled graphs. The integrated transpose engines reduce data preparation overhead by transforming input tiles as they enter the compute pipeline[^4].</p><p><h3>TPC Programming Model</h3></p><p>The TPC’s programming model exposes the VLIW nature directly: kernels schedule instructions across the Vector, Scalar, Load, and Store slots. The Load and Store slots include AGUs for 5-D addressing, making strided, indirect, or padded access patterns first-class citizens. The vector register file and 80 KB VLM provide data locality that is both programmer-visible and compiler-manageable. Latency hiding is part of the microarchitecture, but practical throughput depends on kernel authors explicitly overlapping memory operations with compute and on the compiler’s ability to orchestrate slot utilization[^5].</p><p>The public documentation for TPC intrinsics and the precise instruction encoding is not fully available via standard doc pages. Users rely on the TPC Kernel Libraries and custom kernel repositories to build and integrate kernels, using the provided compiler, assembler, and simulator toolchain[^12][^13][^14][^15].</p><p>
<h2>Memory Hierarchy and Cache Behavior</h2></p><p>Gaudi2’s memory subsystem is unified across L2, L3, and HBM, with uniform HBM mapping via the MMU. Each DCORE includes a 24 MB L2 cache; L3 is uniformly distributed across DCOREs. This arrangement places significant, near-compute capacity close to the MMEs and TPCs while preserving a coherent, uniform view of memory for software. The on-die SRAM (48 MB in Gaudi2) complements L2/L3 as a high-bandwidth, low-latency scratch that can be explicitly steered by cache directives[^1][^4][^5].</p><p>!<a href=".pdf_temp/viewrange_chunk_2_6_10_1762065675/images/ekgysp.jpg">Memory subsystem logical view with unified L2/L3/HBM</a></p><p>Gaudi introduces two mechanisms that matter greatly to performance portability: cache directives and MCID-based cache management. Cache directives—No-$, L2$, L3$, and L2$+L3$—let the compiler/runtime hint or dictate where data should reside, while MCID tags cache lines with a context identifier tied to algorithmic phases or shared uses. Discard invalidates all lines with a given MCID; Degrade resets their hit counts, which can be useful to reduce pollution from hot lines that are no longer structurally reusable[^4][^5].</p><p>Table 5 summarizes the memory hierarchy and bandwidth expectations by generation.</p><p>Table 5: Memory hierarchy summary and bandwidth</p><p><tr><td>Generation</td><td>HBM Capacity</td><td>HBM Bandwidth</td><td>On-Die SRAM</td><td>SRAM/L2 Bandwidth</td><td>Cache Organization</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Gaudi</td><td>32 GB</td><td>~0.9 TB/s</td><td>—</td><td>—</td><td>L2/L3 per DCORE (generation-specific)</td></tr>
<tr><td>Gaudi2</td><td>96 GB</td><td>~2.45 TB/s</td><td>48 MB</td><td>~6.4 TB/s read / ~6.4 TB/s write (L2 cache)</td><td>L2 per DCORE (24 MB); L3 distributed[^1]</td></tr>
<tr><td>Gaudi3</td><td>128 GB</td><td>~3.7 TB/s</td><td>96 MB</td><td>~12.8 TB/s read / ~6.4 TB/s write</td><td>L2 per DCORE (24 MB); L3 distributed[^4][^5]</td></tr></p><p>Table 6 frames the cache directives and MCID operations and when to apply them.</p><p>Table 6: Cache directives and MCID operations</p><p><tr><td>Mechanism</td><td>Purpose</td><td>When to Use</td><td>Effect</td><td>Cautions</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>No-$</td><td>Bypass caches</td><td>Large, streaming or write-once tensors</td><td>Avoid cache pollution</td><td>May increase HBM traffic</td></tr>
<tr><td>L2$</td><td>Favor L2 residency</td><td>Tiles re-used within a DCORE</td><td>Low-latency hits in local DCORE</td><td>May evict other working sets</td></tr>
<tr><td>L3$</td><td>Favor distributed L3</td><td>Cross-DCORE reuse patterns</td><td>Broader reuse without HBM</td><td>Coordination needed for coherence</td></tr>
<tr><td>L2$+L3$</td><td>Dual residency</td><td>Producer–consumer across DCOREs</td><td>Balanced latency/bandwidth</td><td>Larger footprint; watch eviction</td></tr>
<tr><td>MCID: Discard</td><td>Invalidate lines</td><td>Phase transitions</td><td>Clears stale hot lines</td><td>Data must be regenerated/reloaded</td></tr>
<tr><td>MCID: Degrade</td><td>Reset hit counts</td><td>Retain lines but reduce prominence</td><td>Mitigate false sharing of hot sets</td><td>Requires careful measurement</td></tr></p><p>In practice, tensor layout, tiling strategy, and cache directive selection determine whether the working set fits in on-die SRAM/L2 or spills to HBM. The integrated near-memory compute (Add/Sub/Max/Min) can further reduce round trips by performing reductions close to data, particularly for normalization and activation aggregation steps[^4][^5].</p><p>
<h2>Control Path, Submission/Completion, and Firmware Interactions</h2></p><p>Gaudi’s control path is a programmable, low-latency, high-throughput subsystem designed to orchestrate parallel execution across MMEs, TPCs, the NIC, and media engines. Its core primitives—Submission Queues (SQs), Completion Queues (CQs), Sync Manager (SM), and Interrupt Manager (INTR)—expose a minimal, composable interface to the driver stack[^4].</p><p>The driver constructs jobs and dependencies, writes work descriptors to SQs, and waits on completions posted to CQs. The Sync Manager tracks hardware events and dependencies, dispatching work to the right engine and gating start-of-job until inputs are ready. The Interrupt Manager marshals asynchronous events back to the kernel driver with minimal latency.</p><p>!<a href=".pdf_temp/viewrange_chunk_2_6_10_1762065676/images/tmofmm.jpg">Control Path block diagram: SQ/CQ, Sync Manager, Interrupt Manager</a></p><p>Table 7 maps control path components to their functions and typical driver interactions.</p><p>Table 7: Control path components and driver interactions</p><p><tr><td>Component</td><td>Function</td><td>Driver Interaction</td></tr>
<tr><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Submission Queue (SQ)</td><td>Enqueue engine jobs and descriptors</td><td>Map buffers, write job control blocks, ring doorbells</td></tr>
<tr><td>Completion Queue (CQ)</td><td>Receive completion and status events</td><td>Poll or wait on CQ entries; read status/errors</td></tr>
<tr><td>Sync Manager (SM)</td><td>Manage dependencies and dispatch</td><td>Configure event counts and gating conditions</td></tr>
<tr><td>Interrupt Manager (INTR)</td><td>Signal asynchronous events</td><td>Register ISR/thread handlers; mask/unmask sources</td></tr></p><p>The separation of submission/completion from synchronization mirrors classical hardware–software co-design: the driver orchestrates data movement (via DMA and cache directives), while the control path ensures compute engines only start when data is ready and other dependencies are satisfied. This keeps critical paths simple, debuggable, and efficient[^4].</p><p>
<h2>Driver Internals: Linux Kernel and User Mode Stack</h2></p><p>The Linux kernel driver for Gaudi devices exposes the device via a char driver interface, creates device nodes, and integrates with DMA and interrupt subsystems. User-space interacts through a User Mode Driver (UMD) that forwards graph jobs and kernel invocations to the kernel driver. The graph compiler sits above the UMD, determining engine assignments, MME configurations, and TPC kernel launch ordering, as well as collective communication strategies via HCCL (Habana Collective Communication Library)[^4][^12].</p><p>Table 8 outlines the kernel-to-user call path.</p><p>Table 8: Kernel-to-user call path</p><p><tr><td>Layer</td><td>Responsibility</td><td>Examples</td></tr>
<tr><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Kernel Driver (KMD)</td><td>Device initialization, MMIO, DMA mapping, interrupts</td><td>PCI enumeration, SQ/CQ doorbells, ISR handling</td></tr>
<tr><td>UMD</td><td>User-space API, job submission, runtime coordination</td><td>Graph execution, kernel launching</td></tr>
<tr><td>Graph Compiler</td><td>Static scheduling, engine partitioning, fusion</td><td>MME vs TPC assignment, cache directive insertion</td></tr>
<tr><td>HCCL</td><td>Collective operations over integrated NIC</td><td>All-reduce, broadcast, barrier</td></tr></p><p>While public documentation explains the software layering and responsibilities, precise register map details and performance counter interfaces are not comprehensively published. Those are left to firmware Interface Design Specification (IDS) and driver source review for exact fields and semantics[^12].</p><p>
<h2>Register-Level Programming and MMIO View</h2></p><p>At the register level, Gaudi exposes control through memory-mapped I/O (MMIO) registers and queue structures. In broad strokes, the driver maps PCI BARs, configures SQ/CQ rings, writes job descriptors (or configuration blocks for the MME), arms interrupts, and monitors status registers. The TPC’s programmable interface is accessed through intrinsics, and its instructions are not directly exposed to the driver in the same way as scalar device registers; the UMD and toolchain manage TPC binary loading and invocation[^4][^11].</p><p>Table 9 sketches a conceptual register map.</p><p>Table 9: Conceptual MMIO regions and usage</p><p><tr><td>Region</td><td>Purpose</td><td>Driver Usage</td></tr>
<tr><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Global Control</td><td>Device-level enable, resets, power/clock controls</td><td>Initialize/finalize device; handle errors</td></tr>
<tr><td>SQ/CQ Registers</td><td>Head/tail pointers, doorbells, enable masks</td><td>Enqueue jobs; notify device; poll/mask completions</td></tr>
<tr><td>Interrupt Control</td><td>Event sources, masks, status</td><td>Register handlers; clear pending events</td></tr>
<tr><td>DMA Engine</td><td>SGL/base/len, channel control, status</td><td>Map SG lists; initiate transfers; check completion</td></tr>
<tr><td>MME Config</td><td>Tensor shapes, strides, precision, transpose</td><td>Write descriptor; arm compute; read status</td></tr>
<tr><td>TPC Control</td><td>Kernel load, start/stop, stream config</td><td>Load kernel; configure launching context</td></tr></p><p>Without a public IDS, the exact register offsets, bitfields, and sequencing constraints are not fully documented. However, the driver architecture and queue-based job submission model are consistent with the control path’s design[^4][^11].</p><p>
<h2>DMA Engine and Data Transfer Mechanics</h2></p><p>Gaudi integrates multiple DMA engines and AGUs to orchestrate data movement in parallel with compute. AGUs embedded in the MME and TPCs support 5-D addressing, out-of-bounds padding, and write prevention, which reduces branchy per-element checks and enables cleaner, higher-throughput kernels. The DMA API used by the driver follows the Linux DMA mapping patterns: drivers allocate coherent or streaming buffers, build scatter–gather lists, and manage synchronization fences appropriate to the transfer type[^4][^17].</p><p>Table 10 summarizes DMA patterns and typical Linux API usage.</p><p>Table 10: DMA patterns and APIs</p><p><tr><td>Pattern</td><td>Use Case</td><td>Linux API Examples</td><td>Notes</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Host→Device (H2D)</td><td>Load weights, inputs</td><td>dma_map_single(), dma_sync_single_for_device()</td><td>Cache invalidation on device</td></tr>
<tr><td>Device→Host (D2H)</td><td>Retrieve results</td><td>dma_map_single(), dma_sync_single_for_cpu()</td><td>Cache writeback on host</td></tr>
<tr><td>Device↔Device (D2D)</td><td>Tile movement, pre-processing</td><td>dmaengine_prep_slave_sg()</td><td>On-die SRAM/L2/L3 placement</td></tr>
<tr><td>Bidirectional</td><td>Pipelined transfers</td><td>As above, plus fences</td><td>Overlap compute and transfer</td></tr></p><p>The key to peak throughput is overlapping transfers and compute using SQ/CQ signaling and Sync Manager gating so that engines only start when their inputs are resident and ready[^4].</p><p>
<h2>PCIe Transactions and Bottleneck Analysis</h2></p><p>The host interface is PCIe Gen4 x16 for Gaudi2. Real-world throughput depends on NUMA locality, CPU PCIe topology, BIOS settings, and concurrent traffic from other devices. Use the hl_thunk bandwidth test plugin to measure PCIe, HBM, and on-die SRAM bandwidth on your platform. The plugin provides expected ranges and pass/fail thresholds (commonly a 10% degradation criterion) to determine whether the platform is performing within spec[^6].</p><p>Table 11 outlines measured ranges and how to interpret them.</p><p>Table 11: PCIe expected ranges and hl_qual thresholds</p><p><tr><td>Platform</td><td>Direction</td><td>Expected (approx.)</td><td>Notes</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Gaudi2 Gen3 CPU path</td><td>H2D</td><td>~11.9 GB/s</td><td>Baseline Gen3 x16[^6]</td></tr>
<tr><td>Gaudi2 Gen3 CPU path</td><td>D2H</td><td>~12.9 GB/s</td><td>Baseline Gen3 x16[^6]</td></tr>
<tr><td>Gaudi2 Gen3</td><td>Bidirectional</td><td>~19.5 GB/s</td><td>Not double of uni-directional[^6]</td></tr>
<tr><td>Gaudi2 Gen4 (PCI test)</td><td>H2D</td><td>~20.9 GB/s</td><td>Gen4 x16 path[^6]</td></tr>
<tr><td>Gaudi2 Gen4 (PCI test)</td><td>D2H</td><td>~23.1 GB/s</td><td>Gen4 x16 path[^6]</td></tr>
<tr><td>Gaudi2 Gen4 (PCI test)</td><td>Bidirectional</td><td>~34.6 GB/s</td><td>Concurrent upload+download[^6]</td></tr>
<tr><td>Gaudi3 Gen5</td><td>H2D</td><td>~39.4 GB/s</td><td>For comparison[^6]</td></tr>
<tr><td>Gaudi3 Gen5</td><td>D2H</td><td>~38.8 GB/s</td><td>For comparison[^6]</td></tr>
<tr><td>Gaudi3 Gen5</td><td>Bidirectional</td><td>~80.4 GB/s</td><td>For comparison[^6]</td></tr></p><p>When PCIe becomes the bottleneck, performance symptoms include reduced tokens/s in inference or elongated step times in training. Remedies include:</p><p>- Improve NUMA locality: attach devices to the same NUMA node as the data loader and application threads.
- Increase host page size (e.g., 2 MB/1 GB huge pages) to reduce TLB pressure and improve scatter–gather efficiency.
- Minimize concurrent PCI traffic by pinning device interrupts and isolating CPUs.
- Coalesce small transfers into larger SG entries to reduce per-transfer overhead.</p><p>Table 12 lists common mitigations.</p><p>Table 12: PCIe bottleneck mitigation checklist</p><p><tr><td>Symptom</td><td>Likely Cause</td><td>Mitigation</td></tr>
<tr><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Tokens/s fluctuates with batch size</td><td>Small, frequent transfers</td><td>Batch H2D/D2H; larger SG entries</td></tr>
<tr><td>Step time spikes during checkpointing</td><td>Concurrent PCIe traffic</td><td>Isolate CPUs; migrate workloads</td></tr>
<tr><td>PCIe below expected on Gen4</td><td>BIOS settings, retimers</td><td>Update firmware; verify PCIe config</td></tr>
<tr><td>Elevated tail latency</td><td>NUMA mismatch</td><td>Rebind devices, threads to NUMA</td></tr></p><p>
<h2>Hardware Counters and Performance Instrumentation</h2></p><p>Public documentation confirms the presence of performance-critical counters and the hl_thunk qualification library for bandwidth tests, but it does not enumerate counter names, bit widths, or register offsets. In practice, developers should:</p><p>- Use vendor-provided qualification and profiling tools to collect device-side and PCIe-level metrics.
- Cross-check host-side perf events (e.g., CPU cycles, cache misses) against device-side counters for phase alignment.
- Leverage the graph compiler’s logging to reason about cache directive placement, engine scheduling, and potential hotspots[^6][^12].</p><p>The absence of a public counter registry is an information gap that limits fine-grained analysis without access to internal specs or NDA driver documentation.</p><p>
<h2>Firmware Interactions and Engine Synchronization</h2></p><p>Firmware mediates engine scheduling and synchronization via the Sync Manager. The driver expresses dependencies as counted events (e.g., “DMA for tile A completes,” “MME stage 1 finishes”), and firmware dispatches dependent work only when conditions are satisfied. This offloads critical-path synchronization from software and reduces jitter under heavy load[^4].</p><p>Table 13 shows typical dependency patterns.</p><p>Table 13: Engine synchronization patterns</p><p><tr><td>Producer</td><td>Consumer</td><td>Dependency</td><td>Sync Point</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>DMA H2D</td><td>MME</td><td>Input tile ready</td><td>SQ + SM event</td></tr>
<tr><td>MME</td><td>TPC</td><td>Activation tile ready</td><td>CQ completion</td></tr>
<tr><td>TPC</td><td>DMA D2H</td><td>Result tile ready</td><td>CQ completion</td></tr>
<tr><td>NIC (All-Reduce)</td><td>MME/TPC</td><td>Gradient shard ready</td><td>NIC completion event</td></tr></p><p>Near-memory compute can sometimes eliminate a producer–consumer hop by performing reductions adjacent to data (e.g., across tiles in SRAM/L2), reducing cross-engine traffic and synchronization overhead[^4][^5].</p><p>
<h2>Power and Thermal Management at Register/Form Factor Level</h2></p><p>Form factor and cooling choices are first-order constraints. OAM modules support up to 900 W (air) and up to ~1200 W (liquid) depending on generation, while PCIe CEM cards target up to ~600 W passive. Side-band interfaces such as I2C and JTAG support board management controller (BMC) integration, telemetry, and field diagnostics. Although register-level power management details (e.g., clock gating and DVFS registers) are not publicly enumerated, the overall power envelope and thermal envelope follow directly from the form factor and cooling solution[^3][^4][^5].</p><p>!<a href=".pdf_temp/viewrange_chunk_2_6_10_1762065678/images/m5hn1d.jpg">OCP baseboard and card features relevant to power/thermal delivery</a></p><p>Table 14 summarizes power/form factor/cooling relationships.</p><p>Table 14: Form factor vs. power vs. cooling</p><p><tr><td>Form Factor</td><td>TDP</td><td>Cooling</td><td>Notes</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>OAM (Gaudi2)</td><td>Up to 900 W</td><td>Air</td><td>Integrated NIC fabric on-baseboard[^3]</td></tr>
<tr><td>OAM (Gaudi3)</td><td>Up to 900–1200 W</td><td>Air/Liquid</td><td>Higher power, 24x 200 GbE NIC[^4][^5]</td></tr>
<tr><td>PCIe CEM</td><td>Up to 600 W</td><td>Passive</td><td>Scale-up via top board; scale-out via host NIC[^3]</td></tr></p><p>
<h2>Appendix A: Glossary</h2></p><p>- MME (Matrix Multiplication Engine): Configurable, systolic array engine for GEMMs and convolutions.
- TPC (Tensor Processor Core): Programmable VLIW SIMD processor for non-GEMM operations.
- DCORE (Deep Learning Core): Cluster of 2x MME, 16x TPC, and 24 MB cache.
- SQ/CQ (Submission/Completion Queues): Control path primitives for job submission and completion.
- Sync Manager (SM): Hardware mechanism to gate and dispatch work based on counted events.
- Interrupt Manager (INTR): Hardware mechanism for asynchronous event signaling to the driver.
- MCID (Memory Context ID): Tagging mechanism for cache lines; enables Discard/Degrade operations.
- AGU (Address Generation Unit): Hardware address calculator for 5-D tensors, OOB padding, write prevention.
- HBM (High Bandwidth Memory): Stacked DRAM memory with high bandwidth.
- VLM (Vector Local Memory): TPC’s local on-chip memory for vector data.</p><p>
<h2>Appendix B: Methodological Notes</h2></p><p>- Architecture continuity: Gaudi3 documentation is used to explain mechanisms that are consistent across Gaudi2 and Gaudi3 (e.g., DCORE clustering, control path primitives). Where specific numbers differ (HBM capacity/bandwidth, PCIe generation, NIC speeds), we explicitly note the generation.
- Information gaps: The public domain does not include a complete Gaudi2 register map (offsets, bitfields), detailed performance counter registry, or a full TPC intrinsics/spec document. These are available in limited internal/firmware IDS and driver sources but not in public documentation[^12][^14][^15][^17].
- Observability: Use the hl_thunk bandwidth tests and vendor profiling tools; corroborate host-side perf with device-side metrics to triangulate bottlenecks[^6][^12].</p><p>
<h2>References</h2></p><p>[^1]: Gaudi Architecture — Habana Documentation. https://docs.habana.ai/en/latest/Gaudi_Overview/Gaudi_Architecture.html</p><p>[^2]: Intel Gaudi 3 AI Accelerator White Paper. https://cdrdv2-public.intel.com/817486/gaudi-3-ai-accelerator-white-paper.pdf</p><p>[^3]: Habana Gaudi Customer Enablement Whitepaper (OAM/PCIe Form Factors, Interfaces). https://cdrdv2-public.intel.com/784833/Gaudi%20Amazon%20EC2%20DL1%20Instances.pdf</p><p>[^4]: Intel Gaudi 3 AI Accelerator — Hot Chips 2024. https://hc2024.hotchips.org/assets/program/conference/day1/60_HC2024.Intel.RomanKaplan.Gaudi3-0826.pdf</p><p>[^5]: Intel Gaudi 3 AI Accelerator — 30-3-30 Overview. https://cdrdv2-public.intel.com/845118/gaudi-3-ai-accelerator-30-3-30.pdf</p><p>[^6]: Bandwidth Test Plugins Design — hl_thunk. https://docs.habana.ai/en/latest/Management_and_Monitoring/Qualification_Library/Bandwidth_Tests_Plugin.html</p><p>[^7]: Stacking Up Intel Gaudi Against Nvidia GPUs For AI — The Next Platform. https://www.nextplatform.com/2024/06/13/stacking-up-intel-gaudi-against-nvidia-gpus-for-ai/</p><p>[^8]: Intel Gaudi 3 vs. Nvidia H100: Enterprise AI Inference — FiberMall. https://www.fibermall.com/blog/intel-gaudi3-vs-nvidia-h100.htm</p><p>[^9]: LLM Training and Inference with Intel Gaudi 2 AI Accelerators — Databricks Blog. https://www.databricks.com/blog/llm-training-and-inference-intel-gaudi2-ai-accelerators</p><p>[^10]: Intel Begins Publishing Habana Labs Gaudi2 Linux Driver Code — Phoronix. https://www.phoronix.com/news/Intel-Gaudi2-Linux-Driver</p><p>[^11]: Linux v6.6.1 — drivers/accel/habanalabs/gaudi/gaudi.c — rabexc.org. https://sbexr.rabexc.org/latest/sources/2e/8a27c3bf394e0b.html</p><p>[^12]: Kernel Libraries — Intel Gaudi Developers. https://developer.habana.ai/get-started/kernel-libraries/</p><p>[^13]: TPC Tools Installation Guide — Habana Docs. https://docs.habana.ai/en/latest/TPC_Tools_Installation/TPC_Tools_Installation_Guide.html</p><p>[^14]: TPC User Guide — Habana Docs. https://docs.habana.ai/en/latest/TPC_User_Guide/TPC_User_Guide.html</p><p>[^15]: TPC Debugger User Guide — Habana Docs. https://docs.habana.ai/en/latest/TPC_Debugger/TPC_Debugger_User_Guide.html</p><p>[^16]: TensorFlow Custom OP Framework — Habana Docs. https://docs.habana.ai/en/latest/TensorFlow_Operators/TF_Operators.html</p><p>[^17]: Dynamic DMA mapping Guide — Linux Kernel Documentation. https://docs.kernel.org/core-api/dma-api-howto.html</p><p>[^18]: PyTorch Mixed Precision — Intel Gaudi Developers. https://developer.habana.ai/tutorials/pytorch-lightning/pytorch-mixed-precision/</p><p>[^19]: Intel Gaudi — Hugging Face Optimization Guide. https://huggingface.co/docs/diffusers/optimization/habana</p>
            </div>

            <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border);">
                <a href="/experiments.html" style="color: var(--accent); text-decoration: none;">← Back to all experiments</a>
            </div>
        </div>
    </section>


    
<footer>
  <div class="container">
    <div class="footer-content">
      <div class="footer-logo">
        <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
      </div>
      <p>Fridays with Faraday - Working with microcontrollers and embedded systems</p>
    </div>
  </div>
</footer>

    <script src="/js/main.js"></script>
</body>
</html>
