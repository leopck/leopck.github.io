<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STM32 DMA ADC - Fridays with Faraday</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        .experiment-header {
            padding: 8rem 0 3rem;
        }
        .experiment-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent), var(--success));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .experiment-meta {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        .content-section {
            margin-bottom: 3rem;
        }
        .content-section h2 {
            font-size: 1.75rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }
        .content-section h3 {
            font-size: 1.25rem;
            margin: 1.5rem 0 0.75rem;
            color: var(--text-primary);
        }
        .content-section p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
            line-height: 1.8;
        }
        .code-block {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
        }
        .code-block pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }
        .highlight { color: var(--accent); }
        .comment { color: #6b7280; }
        .keyword { color: #f59e0b; }
        .string { color: var(--success); }
        .number { color: #8b5cf6; }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        .result-card {
            background: var(--bg-card);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            text-align: center;
        }
        .result-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--success);
            display: block;
            margin-bottom: 0.5rem;
        }
        .result-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="background"></div>
    <div class="grid-overlay"></div>

    <nav>
        <div class="container">
            <a href="/" class="logo">
                <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
            </a>
            <ul class="nav-menu">
                <li><a href="/#work">Work</a></li>
                <li><a href="/experiments.html">Experiments</a></li>
                <li><a href="mailto:your.email@example.com">Contact</a></li>
            </ul>
            <button class="nav-toggle" aria-label="Toggle menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </nav>

    <section class="experiment-header">
        <div class="container">
            <h1 class="experiment-title">High-Speed ADC with DMA</h1>
            <div class="experiment-meta">
                <span class="tag">STM32F4</span>
                <span class="tag">DMA</span>
                <span class="tag">ADC</span>
            </div>
            <p style="color: var(--text-secondary); font-size: 1.1rem; max-width: 800px;">
                Setting up continuous 2 MSPS ADC sampling on STM32F407 using circular DMA buffers. The goal was to capture high-speed analog signals while keeping the CPU free for processing.
            </p>
        </div>
    </section>

    <section>
        <div class="container">
            <div class="results-grid">
                <div class="result-card">
                    <span class="result-value">2M</span>
                    <span class="result-label">Samples/Second</span>
                </div>
                <div class="result-card">
                    <span class="result-value">6%</span>
                    <span class="result-label">CPU Usage</span>
                </div>
                <div class="result-card">
                    <span class="result-value">4KB</span>
                    <span class="result-label">Buffer Size</span>
                </div>
                <div class="result-card">
                    <span class="result-value">0</span>
                    <span class="result-label">Samples Lost</span>
                </div>
            </div>

            <div class="content-section">
                <h2>The Goal</h2>
                <p>
                    I needed to continuously sample an analog signal at 2 MHz for a digital oscilloscope project. Polling or interrupt-based ADC would eat all the CPU time, so DMA was the obvious choice. The challenge was setting everything up correctly to avoid dropped samples.
                </p>
                <p>
                    Hardware: STM32F407VG running at 168 MHz, 12-bit ADC, APB2 @ 84 MHz.
                </p>
            </div>

            <div class="content-section">
                <h2>ADC Configuration</h2>
                <p>First, configure the ADC for maximum speed. The STM32F4 ADC can run at up to 36 MHz in triple mode, but I only needed one channel.</p>
                
                <div class="code-block">
                    <pre><span class="keyword">#include</span> <span class="string">"stm32f4xx_hal.h"</span>

ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

<span class="keyword">#define</span> ADC_BUFFER_SIZE  <span class="number">2048</span>  <span class="comment">// Circular buffer (half-buffer size)</span>
<span class="keyword">uint16_t</span> adc_buffer[ADC_BUFFER_SIZE * <span class="number">2</span>];

<span class="keyword">void</span> ADC_Init() {
    <span class="comment">// Enable ADC and DMA clocks</span>
    __HAL_RCC_ADC1_CLK_ENABLE();
    __HAL_RCC_DMA2_CLK_ENABLE();
    
    <span class="comment">// Configure ADC</span>
    hadc1.Instance = ADC1;
    hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;  <span class="comment">// 84MHz / 2 = 42MHz</span>
    hadc1.Init.Resolution = ADC_RESOLUTION_12B;
    hadc1.Init.ScanConvMode = DISABLE;
    hadc1.Init.ContinuousConvMode = ENABLE;  <span class="comment">// Continuous sampling</span>
    hadc1.Init.DiscontinuousConvMode = DISABLE;
    hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc1.Init.NbrOfConversion = <span class="number">1</span>;
    hadc1.Init.DMAContinuousRequests = ENABLE;  <span class="comment">// DMA circular mode</span>
    hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
    
    HAL_ADC_Init(&hadc1);
    
    <span class="comment">// Configure channel (PA0 = ADC1_IN0)</span>
    ADC_ChannelConfTypeDef sConfig = {<span class="number">0</span>};
    sConfig.Channel = ADC_CHANNEL_0;
    sConfig.Rank = <span class="number">1</span>;
    sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;  <span class="comment">// Fastest: 3 cycles</span>
    HAL_ADC_ConfigChannel(&hadc1, &sConfig);
}</pre>
                </div>

                <p>With 3 cycle sampling time and 12-bit resolution, the conversion time is: 3 + 12 = 15 cycles at 42 MHz = 2.8 MSPS theoretical max.</p>
            </div>

            <div class="content-section">
                <h2>DMA Setup</h2>
                <p>The DMA controller transfers ADC data to memory without CPU intervention. Using circular mode with half-transfer and full-transfer interrupts for double buffering.</p>
                
                <div class="code-block">
                    <pre><span class="keyword">void</span> DMA_Init() {
    <span class="comment">// DMA2 Stream 0 handles ADC1</span>
    hdma_adc1.Instance = DMA2_Stream0;
    hdma_adc1.Init.Channel = DMA_CHANNEL_0;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;       <span class="comment">// ADC register doesn't move</span>
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;           <span class="comment">// Memory address increments</span>
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;  <span class="comment">// 16-bit ADC</span>
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;                <span class="comment">// Circular buffer</span>
    hdma_adc1.Init.Priority = DMA_PRIORITY_VERY_HIGH;
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    
    HAL_DMA_Init(&hdma_adc1);
    
    <span class="comment">// Link DMA to ADC</span>
    __HAL_LINKDMA(&hadc1, DMA_Handle, hdma_adc1);
    
    <span class="comment">// Enable DMA interrupts</span>
    HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, <span class="number">0</span>, <span class="number">0</span>);
    HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
}

<span class="keyword">void</span> Start_ADC_DMA() {
    <span class="comment">// Start ADC with DMA in circular mode</span>
    HAL_ADC_Start_DMA(&hadc1, (<span class="keyword">uint32_t</span>*)adc_buffer, ADC_BUFFER_SIZE * <span class="number">2</span>);
}</pre>
                </div>
            </div>

            <div class="content-section">
                <h2>Double Buffering</h2>
                <p>With circular DMA, we get two interrupts: half-transfer complete and full-transfer complete. This creates a natural double buffer.</p>
                
                <div class="code-block">
                    <pre><span class="comment">// DMA interrupt callbacks</span>
<span class="keyword">volatile bool</span> buffer_ready = <span class="keyword">false</span>;
<span class="keyword">volatile uint16_t</span>* active_buffer;

<span class="comment">// Called when first half of buffer is full</span>
<span class="keyword">void</span> HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc) {
    <span class="comment">// First half ready, DMA is now filling second half</span>
    active_buffer = &adc_buffer[<span class="number">0</span>];
    buffer_ready = <span class="keyword">true</span>;
}

<span class="comment">// Called when second half of buffer is full</span>
<span class="keyword">void</span> HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    <span class="comment">// Second half ready, DMA wrapped around to first half</span>
    active_buffer = &adc_buffer[ADC_BUFFER_SIZE];
    buffer_ready = <span class="keyword">true</span>;
}

<span class="comment">// Main processing loop</span>
<span class="keyword">void</span> main_loop() {
    <span class="keyword">while</span>(<span class="number">1</span>) {
        <span class="keyword">if</span> (buffer_ready) {
            buffer_ready = <span class="keyword">false</span>;
            
            <span class="comment">// Process ADC_BUFFER_SIZE samples while DMA fills the other half</span>
            process_samples(active_buffer, ADC_BUFFER_SIZE);
        }
    }
}</pre>
                </div>
            </div>

            <div class="content-section">
                <h2>Testing and Verification</h2>
                <p>To verify the setup, I measured actual sample rate and checked for dropped samples:</p>
                
                <div class="terminal">
                    <div class="terminal-header">
                        <div class="terminal-dot" style="background: #ff5f56;"></div>
                        <div class="terminal-dot" style="background: #ffbd2e;"></div>
                        <div class="terminal-dot" style="background: #27c93f;"></div>
                    </div>
                    <div class="terminal-content">
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">st-flash write firmware.bin 0x8000000</span>
                        </div>
                        <div class="terminal-line output">
                            st-flash 1.7.0
                        </div>
                        <div class="terminal-line output">
                            2024-01-15T14:23:45 INFO common.c: F407VG: 192 KiB SRAM, 1024 KiB flash
                        </div>
                        <div class="terminal-line output">
                            2024-01-15T14:23:45 INFO common.c: Attempting to write 24576 bytes
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            2024-01-15T14:23:46 INFO common.c: Flash written and verified! jolly good!
                        </div>
                        <div class="terminal-line">&nbsp;</div>
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">minicom -D /dev/ttyUSB0 -b 115200</span>
                        </div>
                        <div class="terminal-line output">
                            ADC DMA Test Starting...
                        </div>
                        <div class="terminal-line output">
                            Buffer size: 2048 samples
                        </div>
                        <div class="terminal-line output">
                            Target rate: 2.0 MSPS
                        </div>
                        <div class="terminal-line output">&nbsp;</div>
                        <div class="terminal-line output" style="color: #10b981;">
                            ✓ Actual sample rate: 2.00 MSPS
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            ✓ Buffer overruns: 0
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            ✓ CPU usage: 6% (processing + USB transfer)
                        </div>
                    </div>
                </div>
            </div>

            <div class="content-section">
                <h2>Optimization: Processing Time</h2>
                <p>With 2 MSPS and 2048-sample buffers, each half fills in ~1ms. The processing must complete faster than that to avoid overruns.</p>
                
                <div class="code-block">
                    <pre><span class="comment">// Simple processing example - peak detection</span>
<span class="keyword">void</span> process_samples(<span class="keyword">const uint16_t</span>* samples, <span class="keyword">uint32_t</span> count) {
    <span class="keyword">static uint32_t</span> process_cycles = <span class="number">0</span>;
    
    DWT-&gt;CYCCNT = <span class="number">0</span>;  <span class="comment">// Reset cycle counter</span>
    
    <span class="keyword">uint16_t</span> max_val = <span class="number">0</span>;
    <span class="keyword">uint16_t</span> min_val = <span class="number">4095</span>;
    
    <span class="comment">// Process samples - this must be fast!</span>
    <span class="keyword">for</span>(<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; count; i++) {
        <span class="keyword">if</span>(samples[i] &gt; max_val) max_val = samples[i];
        <span class="keyword">if</span>(samples[i] &lt; min_val) min_val = samples[i];
    }
    
    process_cycles = DWT-&gt;CYCCNT;
    
    <span class="comment">// At 168 MHz, we have 168,000 cycles per 1ms buffer</span>
    <span class="comment">// This simple loop takes ~8,000 cycles = 47µs ✓</span>
}</pre>
                </div>

                <div class="terminal">
                    <div class="terminal-header">
                        <div class="terminal-dot" style="background: #ff5f56;"></div>
                        <div class="terminal-dot" style="background: #ffbd2e;"></div>
                        <div class="terminal-dot" style="background: #27c93f;"></div>
                    </div>
                    <div class="terminal-content">
                        <div class="terminal-line output">
                            Processing time: 47 µs / 1024 µs available
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            Margin: 95.4% (plenty of headroom for FFT, etc.)
                        </div>
                    </div>
                </div>
            </div>

            <div class="content-section">
                <h2>Complete Working Code</h2>
                
                <div class="code-block">
                    <pre><span class="comment">// main.c - Complete example</span>
<span class="keyword">#include</span> <span class="string">"stm32f4xx_hal.h"</span>

<span class="keyword">#define</span> BUFFER_SIZE <span class="number">2048</span>
<span class="keyword">uint16_t</span> adc_buffer[BUFFER_SIZE * <span class="number">2</span>];
<span class="keyword">volatile bool</span> buffer_ready = <span class="keyword">false</span>;
<span class="keyword">volatile uint16_t</span>* active_buffer;

ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    HAL_Init();
    SystemClock_Config();  <span class="comment">// 168 MHz</span>
    
    GPIO_Init();
    DMA_Init();
    ADC_Init();
    
    <span class="comment">// Start continuous sampling</span>
    HAL_ADC_Start_DMA(&hadc1, (<span class="keyword">uint32_t</span>*)adc_buffer, BUFFER_SIZE * <span class="number">2</span>);
    
    <span class="keyword">while</span>(<span class="number">1</span>) {
        <span class="keyword">if</span>(buffer_ready) {
            buffer_ready = <span class="keyword">false</span>;
            process_samples(active_buffer, BUFFER_SIZE);
        }
    }
}

<span class="keyword">void</span> HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc) {
    active_buffer = &adc_buffer[<span class="number">0</span>];
    buffer_ready = <span class="keyword">true</span>;
}

<span class="keyword">void</span> HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    active_buffer = &adc_buffer[BUFFER_SIZE];
    buffer_ready = <span class="keyword">true</span>;
}

<span class="keyword">void</span> DMA2_Stream0_IRQHandler(<span class="keyword">void</span>) {
    HAL_DMA_IRQHandler(&hdma_adc1);
}</pre>
                </div>
            </div>

            <div class="content-section">
                <h2>Key Takeaways</h2>
                <p>
                    • DMA is essential for high-speed data acquisition - the CPU can't keep up with 2 MSPS polling.<br>
                    • Circular mode with double buffering provides seamless continuous sampling.<br>
                    • The processing time must be less than the buffer fill time to avoid overruns.<br>
                    • Always measure actual performance - timing calculations don't account for all overhead.<br>
                    • Use the DWT cycle counter for precise performance measurement on Cortex-M4.<br>
                    • With proper setup, you can achieve line rate with minimal CPU usage (6% in this case).
                </p>
            </div>

            <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border);">
                <a href="/experiments.html" style="color: var(--accent); text-decoration: none;">← Back to all experiments</a>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
                </div>
                <p>Fridays with Faraday - Working with microcontrollers and embedded systems</p>
            </div>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>