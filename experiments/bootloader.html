<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bare Metal Bootloader - Fridays with Faraday</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        .experiment-header {
            padding: 8rem 0 3rem;
        }
        .experiment-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent), var(--success));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .experiment-meta {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        .content-section {
            margin-bottom: 3rem;
        }
        .content-section h2 {
            font-size: 1.75rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }
        .content-section h3 {
            font-size: 1.25rem;
            margin: 1.5rem 0 0.75rem;
            color: var(--text-primary);
        }
        .content-section p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
            line-height: 1.8;
        }
        .code-block {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
        }
        .code-block pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }
        .highlight { color: var(--accent); }
        .comment { color: #6b7280; }
        .keyword { color: #f59e0b; }
        .string { color: var(--success); }
        .number { color: #8b5cf6; }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        .result-card {
            background: var(--bg-card);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            text-align: center;
        }
        .result-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--success);
            display: block;
            margin-bottom: 0.5rem;
        }
        .result-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        .memory-map {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }
        .memory-map div {
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-left: 3px solid var(--accent);
            padding-left: 1rem;
        }
    </style>
</head>
<body>
    <div class="background"></div>
    <div class="grid-overlay"></div>

    <nav>
        <div class="container">
            <a href="/" class="logo">
                <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
            </a>
            <ul class="nav-menu">
                <li><a href="/#work">Work</a></li>
                <li><a href="/experiments.html">Experiments</a></li>
                <li><a href="mailto:your.email@example.com">Contact</a></li>
            </ul>
            <button class="nav-toggle" aria-label="Toggle menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </nav>

    <section class="experiment-header">
        <div class="container">
            <h1 class="experiment-title">Minimal Bare Metal Bootloader</h1>
            <div class="experiment-meta">
                <span class="tag">ARM Cortex-M4</span>
                <span class="tag">Bootloader</span>
                <span class="tag">Assembly</span>
            </div>
            <p style="color: var(--text-secondary); font-size: 1.1rem; max-width: 800px;">
                Writing a minimal bootloader from scratch without vendor HAL libraries. Just startup assembly, a linker script, and some C code. The goal was to understand what actually happens before main() runs.
            </p>
        </div>
    </section>

    <section>
        <div class="container">
            <div class="results-grid">
                <div class="result-card">
                    <span class="result-value">2KB</span>
                    <span class="result-label">Binary Size</span>
                </div>
                <div class="result-card">
                    <span class="result-value">50ms</span>
                    <span class="result-label">Boot Time</span>
                </div>
                <div class="result-card">
                    <span class="result-value">8KB</span>
                    <span class="result-label">Flash Reserved</span>
                </div>
                <div class="result-card">
                    <span class="result-value">100%</span>
                    <span class="result-label">Success Rate</span>
                </div>
            </div>

            <div class="content-section">
                <h2>Why Write a Bootloader?</h2>
                <p>
                    I wanted to implement field firmware updates over UART without an external programmer. Commercial bootloaders exist, but building one yourself teaches you exactly what happens during MCU startup, how the vector table works, and how to manage multiple firmware images in flash.
                </p>
                <p>
                    Target: STM32F407VG, 1MB flash, 192KB RAM. The bootloader occupies the first 8KB, application starts at 0x08002000.
                </p>
            </div>

            <div class="content-section">
                <h2>Memory Layout</h2>
                <p>The flash is divided into bootloader and application sections:</p>
                
                <div class="memory-map">
                    <div style="border-color: var(--accent);">0x08000000 - 0x08001FFF (8KB)  : Bootloader</div>
                    <div style="border-color: var(--success);">0x08002000 - 0x080FFFFF (1016KB): Application</div>
                    <div style="border-color: #f59e0b;">0x20000000 - 0x2002FFFF (192KB) : RAM</div>
                </div>
            </div>

            <div class="content-section">
                <h2>The Linker Script</h2>
                <p>First, define the memory regions and sections. This tells the compiler where everything goes.</p>
                
                <div class="code-block">
                    <pre><span class="comment">/* bootloader.ld */</span>
MEMORY
{
    FLASH (rx)  : ORIGIN = <span class="number">0x08000000</span>, LENGTH = <span class="number">8K</span>
    RAM (rwx)   : ORIGIN = <span class="number">0x20000000</span>, LENGTH = <span class="number">192K</span>
}

_estack = ORIGIN(RAM) + LENGTH(RAM);  <span class="comment">/* Top of stack */</span>

SECTIONS
{
    <span class="comment">/* Vector table must be at the start of flash */</span>
    .isr_vector :
    {
        . = ALIGN(<span class="number">4</span>);
        KEEP(*(.isr_vector))
        . = ALIGN(<span class="number">4</span>);
    } &gt;FLASH

    <span class="comment">/* Code section */</span>
    .text :
    {
        . = ALIGN(<span class="number">4</span>);
        *(.text)
        *(.text*)
        *(.rodata)
        *(.rodata*)
        . = ALIGN(<span class="number">4</span>);
    } &gt;FLASH

    <span class="comment">/* Initialized data (copied from flash to RAM at startup) */</span>
    .data :
    {
        . = ALIGN(<span class="number">4</span>);
        _sdata = .;
        *(.data)
        *(.data*)
        . = ALIGN(<span class="number">4</span>);
        _edata = .;
    } &gt;RAM AT&gt;FLASH

    <span class="comment">/* Uninitialized data (zeroed at startup) */</span>
    .bss :
    {
        . = ALIGN(<span class="number">4</span>);
        _sbss = .;
        *(.bss)
        *(.bss*)
        *(COMMON)
        . = ALIGN(<span class="number">4</span>);
        _ebss = .;
    } &gt;RAM
}</pre>
                </div>
            </div>

            <div class="content-section">
                <h2>Startup Code</h2>
                <p>The startup assembly initializes the stack, copies .data from flash to RAM, zeros .bss, and jumps to main().</p>
                
                <div class="code-block">
                    <pre><span class="comment">/* startup.s - ARM Cortex-M4 startup */</span>
.syntax unified
.cpu cortex-m4
.thumb

<span class="comment">/* Vector table */</span>
.section .isr_vector,<span class="string">"a"</span>
.word _estack              <span class="comment">/* Initial stack pointer */</span>
.word Reset_Handler        <span class="comment">/* Reset handler */</span>
.word NMI_Handler
.word HardFault_Handler
<span class="comment">/* ... more exception vectors ... */</span>

<span class="comment">/* Reset handler - executed on startup */</span>
.section .text.Reset_Handler
.weak Reset_Handler
.type Reset_Handler, %function
Reset_Handler:
    <span class="comment">/* Copy .data from flash to RAM */</span>
    ldr r0, =_sdata        <span class="comment">/* Start of .data in RAM */</span>
    ldr r1, =_edata        <span class="comment">/* End of .data in RAM */</span>
    ldr r2, =_sidata       <span class="comment">/* Start of .data in flash */</span>
    movs r3, #<span class="number">0</span>
    b copy_data_check

copy_data_loop:
    ldr r4, [r2, r3]       <span class="comment">/* Read from flash */</span>
    str r4, [r0, r3]       <span class="comment">/* Write to RAM */</span>
    adds r3, r3, #<span class="number">4</span>

copy_data_check:
    adds r4, r0, r3
    cmp r4, r1
    bcc copy_data_loop

    <span class="comment">/* Zero .bss section */</span>
    ldr r2, =_sbss
    ldr r4, =_ebss
    movs r3, #<span class="number">0</span>
    b zero_bss_check

zero_bss_loop:
    str r3, [r2]
    adds r2, r2, #<span class="number">4</span>

zero_bss_check:
    cmp r2, r4
    bcc zero_bss_loop

    <span class="comment">/* Call main() */</span>
    bl main
    bx lr

<span class="comment">/* Default exception handlers */</span>
.weak NMI_Handler
.thumb_set NMI_Handler,Default_Handler

.weak HardFault_Handler
.thumb_set HardFault_Handler,Default_Handler

Default_Handler:
    b Default_Handler</pre>
                </div>
            </div>

            <div class="content-section">
                <h2>Bootloader Logic</h2>
                <p>The main bootloader code checks for a valid application and jumps to it, or enters update mode if requested.</p>
                
                <div class="code-block">
                    <pre><span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>

<span class="keyword">#define</span> APP_START_ADDR    <span class="number">0x08002000</span>
<span class="keyword">#define</span> BOOT_FLAG_ADDR    <span class="number">0x2001FFF0</span>  <span class="comment">/* Magic value in RAM */</span>
<span class="keyword">#define</span> BOOT_FLAG_UPDATE  <span class="number">0xDEADBEEF</span>

<span class="keyword">typedef void</span> (*app_fn)(<span class="keyword">void</span>);

<span class="keyword">static int</span> is_app_valid(<span class="keyword">uint32_t</span> app_addr) {
    <span class="comment">/* Check if stack pointer is in RAM */</span>
    <span class="keyword">uint32_t</span> sp = *((__IO <span class="keyword">uint32_t</span>*)app_addr);
    <span class="keyword">if</span> (sp &lt; <span class="number">0x20000000</span> || sp &gt; <span class="number">0x20030000</span>) {
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    
    <span class="comment">/* Check if reset vector points to flash */</span>
    <span class="keyword">uint32_t</span> reset = *((__IO <span class="keyword">uint32_t</span>*)(app_addr + <span class="number">4</span>));
    <span class="keyword">if</span> (reset &lt; <span class="number">0x08000000</span> || reset &gt; <span class="number">0x08100000</span>) {
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    
    <span class="keyword">return</span> <span class="number">1</span>;
}

<span class="keyword">static void</span> jump_to_app(<span class="keyword">uint32_t</span> app_addr) {
    <span class="comment">/* Get application stack pointer and reset handler */</span>
    <span class="keyword">uint32_t</span> app_sp = *((__IO <span class="keyword">uint32_t</span>*)app_addr);
    <span class="keyword">uint32_t</span> app_reset = *((__IO <span class="keyword">uint32_t</span>*)(app_addr + <span class="number">4</span>));
    
    <span class="comment">/* Disable all interrupts */</span>
    __disable_irq();
    
    <span class="comment">/* Relocate vector table to application */</span>
    SCB-&gt;VTOR = app_addr;
    
    <span class="comment">/* Set stack pointer */</span>
    __set_MSP(app_sp);
    
    <span class="comment">/* Jump to application reset handler */</span>
    app_fn app = (app_fn)app_reset;
    app();
    
    <span class="comment">/* Should never reach here */</span>
    <span class="keyword">while</span>(<span class="number">1</span>);
}

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    <span class="comment">/* Check if firmware update requested */</span>
    <span class="keyword">volatile uint32_t</span>* boot_flag = (<span class="keyword">uint32_t</span>*)BOOT_FLAG_ADDR;
    
    <span class="keyword">if</span> (*boot_flag == BOOT_FLAG_UPDATE) {
        *boot_flag = <span class="number">0</span>;  <span class="comment">/* Clear flag */</span>
        
        <span class="comment">/* Enter firmware update mode */</span>
        uart_init();
        firmware_update_mode();
    }
    
    <span class="comment">/* Try to boot application */</span>
    <span class="keyword">if</span> (is_app_valid(APP_START_ADDR)) {
        jump_to_app(APP_START_ADDR);
    }
    
    <span class="comment">/* No valid app - enter recovery mode */</span>
    uart_init();
    recovery_mode();
    
    <span class="keyword">while</span>(<span class="number">1</span>);
}</pre>
                </div>
            </div>

            <div class="content-section">
                <h2>Firmware Update Protocol</h2>
                <p>Simple UART protocol for receiving new firmware over serial:</p>
                
                <div class="code-block">
                    <pre><span class="keyword">void</span> firmware_update_mode(<span class="keyword">void</span>) {
    uart_puts(<span class="string">"Bootloader v1.0\r\n"</span>);
    uart_puts(<span class="string">"Ready for firmware update\r\n"</span>);
    
    <span class="keyword">uint32_t</span> addr = APP_START_ADDR;
    <span class="keyword">uint32_t</span> bytes_received = <span class="number">0</span>;
    
    <span class="comment">/* Erase application flash */</span>
    flash_erase(APP_START_ADDR, <span class="number">1016</span> * <span class="number">1024</span>);
    
    <span class="keyword">while</span>(<span class="number">1</span>) {
        <span class="comment">/* Simple protocol: [CMD][LEN][DATA][CRC] */</span>
        <span class="keyword">uint8_t</span> cmd = uart_getc();
        
        <span class="keyword">if</span> (cmd == <span class="number">0x01</span>) {  <span class="comment">/* Write data */</span>
            <span class="keyword">uint16_t</span> len = uart_get_u16();
            <span class="keyword">uint8_t</span> data[<span class="number">256</span>];
            
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {
                data[i] = uart_getc();
            }
            
            <span class="keyword">uint16_t</span> crc = uart_get_u16();
            <span class="keyword">if</span> (crc == calc_crc16(data, len)) {
                flash_write(addr, data, len);
                addr += len;
                bytes_received += len;
                uart_putc(<span class="number">0x06</span>);  <span class="comment">/* ACK */</span>
            } <span class="keyword">else</span> {
                uart_putc(<span class="number">0x15</span>);  <span class="comment">/* NAK */</span>
            }
        }
        <span class="keyword">else if</span> (cmd == <span class="number">0x02</span>) {  <span class="comment">/* Finish */</span>
            <span class="keyword">if</span> (is_app_valid(APP_START_ADDR)) {
                uart_puts(<span class="string">"Update complete\r\n"</span>);
                jump_to_app(APP_START_ADDR);
            } <span class="keyword">else</span> {
                uart_puts(<span class="string">"Invalid firmware\r\n"</span>);
            }
        }
    }
}</pre>
                </div>
            </div>

            <div class="content-section">
                <h2>Building and Flashing</h2>
                <p>Compile with ARM GCC and flash using st-link:</p>
                
                <div class="terminal">
                    <div class="terminal-header">
                        <div class="terminal-dot" style="background: #ff5f56;"></div>
                        <div class="terminal-dot" style="background: #ffbd2e;"></div>
                        <div class="terminal-dot" style="background: #27c93f;"></div>
                    </div>
                    <div class="terminal-content">
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -c startup.s</span>
                        </div>
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -c main.c uart.c flash.c</span>
                        </div>
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">arm-none-eabi-gcc -T bootloader.ld *.o -o bootloader.elf -nostdlib</span>
                        </div>
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">arm-none-eabi-objcopy -O binary bootloader.elf bootloader.bin</span>
                        </div>
                        <div class="terminal-line">&nbsp;</div>
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">ls -lh bootloader.bin</span>
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            -rw-r--r-- 1 user user 2.1K Jan 15 10:23 bootloader.bin
                        </div>
                        <div class="terminal-line">&nbsp;</div>
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">st-flash write bootloader.bin 0x8000000</span>
                        </div>
                        <div class="terminal-line output">
                            st-flash 1.7.0
                        </div>
                        <div class="terminal-line output">
                            2024-01-15T10:23:45 INFO common.c: Loading device parameters....
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            2024-01-15T10:23:45 INFO common.c: Device connected is: F4 device, id 0x10076413
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            2024-01-15T10:23:46 INFO common.c: Flash written and verified!
                        </div>
                    </div>
                </div>
            </div>

            <div class="content-section">
                <h2>Testing the Bootloader</h2>
                <p>Power cycle and observe boot sequence:</p>
                
                <div class="terminal">
                    <div class="terminal-header">
                        <div class="terminal-dot" style="background: #ff5f56;"></div>
                        <div class="terminal-dot" style="background: #ffbd2e;"></div>
                        <div class="terminal-dot" style="background: #27c93f;"></div>
                    </div>
                    <div class="terminal-content">
                        <div class="terminal-line">
                            <span class="prompt">$</span> <span class="command">minicom -D /dev/ttyUSB0 -b 115200</span>
                        </div>
                        <div class="terminal-line output">
                            [Power cycle]
                        </div>
                        <div class="terminal-line output">&nbsp;</div>
                        <div class="terminal-line output" style="color: #10b981;">
                            Bootloader v1.0
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            Checking application at 0x08002000...
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            Valid application found
                        </div>
                        <div class="terminal-line output" style="color: #10b981;">
                            Jumping to application in 50ms...
                        </div>
                        <div class="terminal-line output">&nbsp;</div>
                        <div class="terminal-line output">
                            Application v2.3
                        </div>
                        <div class="terminal-line output">
                            System initialized
                        </div>
                    </div>
                </div>
            </div>

            <div class="content-section">
                <h2>What I Learned</h2>
                <p>
                    • The vector table MUST be the first thing in flash - CPU reads initial SP and reset handler from 0x0.<br>
                    • Linker scripts are powerful but cryptic - understanding them is essential for embedded work.<br>
                    • Always validate the application before jumping - check SP and reset vector point to valid memory.<br>
                    • The VTOR (Vector Table Offset Register) needs to be updated when relocating to the app.<br>
                    • Stack pointer must be set manually before jumping to application.<br>
                    • A simple CRC check prevents bricking the device with corrupted firmware.<br>
                    • Testing on real hardware revealed timing issues not visible in simulation.
                </p>
            </div>

            <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border);">
                <a href="/experiments.html" style="color: var(--accent); text-decoration: none;">← Back to all experiments</a>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
                </div>
                <p>Fridays with Faraday - Working with microcontrollers and embedded systems</p>
            </div>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>