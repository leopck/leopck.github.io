
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>High-Speed ADC with DMA - Fridays with Faraday</title>
  <meta name="description" content="**STM32F4** **DMA** **ADC**">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="alternate" type="application/rss+xml" title="Fridays with Faraday" href="../rss.xml">
</head>
<body>
  <div class="background"></div>
  <div class="grid-overlay"></div>

  
<nav>
  <div class="container">
    <a href="/" class="logo">
      <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
    </a>
    <ul class="nav-menu">
      <li><a href="/#work">Work</a></li>
      <li><a href="/experiments.html" class="active">Experiments</a></li>
      <li><a href="/search.html">Search</a></li>
      <li><a href="mailto:your.email@example.com">Contact</a></li>
    </ul>
    <button class="nav-toggle" aria-label="Toggle menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
  </div>
</nav>

  
<section class="experiment-header">
  <div class="container">
    <h1 class="experiment-title">High-Speed ADC with DMA</h1>
    <div class="experiment-meta">
      <span class="tag">experiments</span>
      
      <span class="tag difficulty-intermediate">intermediate</span>
    </div>
    <div class="post-meta">
      <span class="meta-item">
        <strong>Date:</strong> 11/2/2025
      </span>
      <span class="meta-item">
        <strong>Read Time:</strong> undefined
      </span>
      <span class="meta-item">
        <strong>Author:</strong> 
      </span>
    </div>
    <p class="post-description">**STM32F4** **DMA** **ADC**</p>
  </div>
</section>

<section>
  <div class="container">
    <div class="content-layout">
      <main class="content-main">
        
    <div class="toc">
      <h3>Table of Contents</h3>
      <nav class="toc-nav">
        <a href="#high-speed-adc-with-dma" class="toc-link toc-level-1">
            High-Speed ADC with DMA
          </a>
        <a href="#results" class="toc-link toc-level-2">
              Results
          </a>
        <a href="#the-goal" class="toc-link toc-level-2">
              The Goal
          </a>
        <a href="#adc-configuration" class="toc-link toc-level-2">
              ADC Configuration
          </a>
        <a href="#dma-setup" class="toc-link toc-level-2">
              DMA Setup
          </a>
        <a href="#double-buffering" class="toc-link toc-level-2">
              Double Buffering
          </a>
        <a href="#testing-and-verification" class="toc-link toc-level-2">
              Testing and Verification
          </a>
        <a href="#optimization-processing-time" class="toc-link toc-level-2">
              Optimization: Processing Time
          </a>
        <a href="#complete-working-code" class="toc-link toc-level-2">
              Complete Working Code
          </a>
        <a href="#key-takeaways" class="toc-link toc-level-2">
              Key Takeaways
          </a>
      </nav>
    </div>
  
        <div class="post-content">
          <p><h1 id="high-speed-adc-with-dma">High-Speed ADC with DMA</h1></p><p><strong>STM32F4<em>* **DMA** *</em>ADC</strong></p><p>Setting up continuous 2 MSPS ADC sampling on STM32F407 using circular DMA buffers. The goal was to capture high-speed analog signals while keeping the CPU free for processing.</p><p>---</p><p><h2 id="results">Results</h2></p><p><tr><td>Metric</td><td>Value</td></tr>
<tr><td>--------</td><td>-------</td></tr>
<tr><td><strong>Samples/Second</strong></td><td>2M</td></tr>
<tr><td><strong>CPU Usage</strong></td><td>6%</td></tr>
<tr><td><strong>Buffer Size</strong></td><td>4KB</td></tr>
<tr><td><strong>Samples Lost</strong></td><td>0</td></tr></p><p>---</p><p><h2 id="the-goal">The Goal</h2></p><p>I needed to continuously sample an analog signal at 2 MHz for a digital oscilloscope project. Polling or interrupt-based ADC would eat all the CPU time, so DMA was the obvious choice. The challenge was setting everything up correctly to avoid dropped samples.</p><p>Hardware: STM32F407VG running at 168 MHz, 12-bit ADC, APB2 @ 84 MHz.</p><p>---</p><p><h2 id="adc-configuration">ADC Configuration</h2></p><p>First, configure the ADC for maximum speed. The STM32F4 ADC can run at up to 36 MHz in triple mode, but I only needed one channel.</p><p><div class="code-block"><pre><code class="language-c">#include &quot;stm32f4xx_hal.h&quot;</p><p>ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;</p><p>#define ADC_BUFFER_SIZE  2048  // Circular buffer (half-buffer size)
uint16_t adc_buffer[ADC_BUFFER_SIZE * 2];</p><p>void ADC_Init() {
    // Enable ADC and DMA clocks
    __HAL_RCC_ADC1_CLK_ENABLE();
    __HAL_RCC_DMA2_CLK_ENABLE();
    
    // Configure ADC
    hadc1.Instance = ADC1;
    hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;  // 84MHz / 2 = 42MHz
    hadc1.Init.Resolution = ADC_RESOLUTION_12B;
    hadc1.Init.ScanConvMode = DISABLE;
    hadc1.Init.ContinuousConvMode = ENABLE;  // Continuous sampling
    hadc1.Init.DiscontinuousConvMode = DISABLE;
    hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc1.Init.NbrOfConversion = 1;
    hadc1.Init.DMAContinuousRequests = ENABLE;  // DMA circular mode
    hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
    
    HAL_ADC_Init(&amp;hadc1);
    
    // Configure channel (PA0 = ADC1_IN0)
    ADC_ChannelConfTypeDef sConfig = {0};
    sConfig.Channel = ADC_CHANNEL_0;
    sConfig.Rank = 1;
    sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;  // Fastest: 3 cycles
    HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig);
}</code></pre></div></p><p>With 3 cycle sampling time and 12-bit resolution, the conversion time is: 3 + 12 = 15 cycles at 42 MHz = 2.8 MSPS theoretical max.</p><p>---</p><p><h2 id="dma-setup">DMA Setup</h2></p><p>The DMA controller transfers ADC data to memory without CPU intervention. Using circular mode with half-transfer and full-transfer interrupts for double buffering.</p><p><div class="code-block"><pre><code class="language-c">void DMA_Init() {
    // DMA2 Stream 0 handles ADC1
    hdma_adc1.Instance = DMA2_Stream0;
    hdma_adc1.Init.Channel = DMA_CHANNEL_0;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;       // ADC register doesn&#039;t move
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;           // Memory address increments
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;  // 16-bit ADC
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;                // Circular buffer
    hdma_adc1.Init.Priority = DMA_PRIORITY_VERY_HIGH;
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    
    HAL_DMA_Init(&amp;hdma_adc1);
    
    // Link DMA to ADC
    __HAL_LINKDMA(&amp;hadc1, DMA_Handle, hdma_adc1);
    
    // Enable DMA interrupts
    HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
}</p><p>void Start_ADC_DMA() {
    // Start ADC with DMA in circular mode
    HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t<em>)adc_buffer, ADC_BUFFER_SIZE </em> 2);
}</code></pre></div></p><p>---</p><p><h2 id="double-buffering">Double Buffering</h2></p><p>With circular DMA, we get two interrupts: half-transfer complete and full-transfer complete. This creates a natural double buffer.</p><p><div class="code-block"><pre><code class="language-c">// DMA interrupt callbacks
volatile bool buffer_ready = false;
volatile uint16_t* active_buffer;</p><p>// Called when first half of buffer is full
void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc) {
    // First half ready, DMA is now filling second half
    active_buffer = &amp;adc_buffer[0];
    buffer_ready = true;
}</p><p>// Called when second half of buffer is full
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    // Second half ready, DMA wrapped around to first half
    active_buffer = &amp;adc_buffer[ADC_BUFFER_SIZE];
    buffer_ready = true;
}</p><p>// Main processing loop
void main_loop() {
    while(1) {
        if (buffer_ready) {
            buffer_ready = false;
            
            // Process ADC_BUFFER_SIZE samples while DMA fills the other half
            process_samples(active_buffer, ADC_BUFFER_SIZE);
        }
    }
}</code></pre></div></p><p>---</p><p><h2 id="testing-and-verification">Testing and Verification</h2></p><p>To verify the setup, I measured actual sample rate and checked for dropped samples:</p><p><div class="code-block"><pre><code class="language-text">$ st-flash write firmware.bin 0x8000000
st-flash 1.7.0
2024-01-15T14:23:45 INFO common.c: F407VG: 192 KiB SRAM, 1024 KiB flash
2024-01-15T14:23:45 INFO common.c: Attempting to write 24576 bytes
2024-01-15T14:23:46 INFO common.c: Flash written and verified! jolly good!</p><p>$ minicom -D /dev/ttyUSB0 -b 115200
ADC DMA Test Starting...
Buffer size: 2048 samples
Target rate: 2.0 MSPS</p><p>✓ Actual sample rate: 2.00 MSPS
✓ Buffer overruns: 0
✓ CPU usage: 6% (processing + USB transfer)</code></pre></div></p><p>---</p><p><h2 id="optimization-processing-time">Optimization: Processing Time</h2></p><p>With 2 MSPS and 2048-sample buffers, each half fills in ~1ms. The processing must complete faster than that to avoid overruns.</p><p><div class="code-block"><pre><code class="language-c">// Simple processing example - peak detection
void process_samples(const uint16_t* samples, uint32_t count) {
    static uint32_t process_cycles = 0;
    
    DWT-&gt;CYCCNT = 0;  // Reset cycle counter
    
    uint16_t max_val = 0;
    uint16_t min_val = 4095;
    
    // Process samples - this must be fast!
    for(uint32_t i = 0; i &lt; count; i++) {
        if(samples[i] &gt; max_val) max_val = samples[i];
        if(samples[i] &lt; min_val) min_val = samples[i];
    }
    
    process_cycles = DWT-&gt;CYCCNT;
    
    // At 168 MHz, we have 168,000 cycles per 1ms buffer
    // This simple loop takes ~8,000 cycles = 47µs ✓
}</code></pre></div></p><p><div class="code-block"><pre><code class="language-text">Processing time: 47 µs / 1024 µs available
Margin: 95.4% (plenty of headroom for FFT, etc.)</code></pre></div></p><p>---</p><p><h2 id="complete-working-code">Complete Working Code</h2></p><p><div class="code-block"><pre><code class="language-c">// main.c - Complete example
#include &quot;stm32f4xx_hal.h&quot;</p><p>#define BUFFER_SIZE 2048
uint16_t adc_buffer[BUFFER_SIZE * 2];
volatile bool buffer_ready = false;
volatile uint16_t* active_buffer;</p><p>ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;</p><p>int main(void) {
    HAL_Init();
    SystemClock_Config();  // 168 MHz
    
    GPIO_Init();
    DMA_Init();
    ADC_Init();
    
    // Start continuous sampling
    HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t<em>)adc_buffer, BUFFER_SIZE </em> 2);
    
    while(1) {
        if(buffer_ready) {
            buffer_ready = false;
            process_samples(active_buffer, BUFFER_SIZE);
        }
    }
}</p><p>void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc) {
    active_buffer = &amp;adc_buffer[0];
    buffer_ready = true;
}</p><p>void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    active_buffer = &amp;adc_buffer[BUFFER_SIZE];
    buffer_ready = true;
}</p><p>void DMA2_Stream0_IRQHandler(void) {
    HAL_DMA_IRQHandler(&amp;hdma_adc1);
}</code></pre></div></p><p>---</p><p><h2 id="key-takeaways">Key Takeaways</h2></p><p>• <strong>DMA is essential</strong> for high-speed data acquisition - the CPU can't keep up with 2 MSPS polling.</p><p>• <strong>Circular mode with double buffering</strong> provides seamless continuous sampling.</p><p>• <strong>The processing time must be less than the buffer fill time</strong> to avoid overruns.</p><p>• <strong>Always measure actual performance</strong> - timing calculations don't account for all overhead.</p><p>• <strong>Use the DWT cycle counter</strong> for precise performance measurement on Cortex-M4.</p><p>• <strong>With proper setup</strong>, you can achieve line rate with minimal CPU usage (6% in this case).</p><p>---</p><p><em>← Back to all experiments</em>
</p>
        </div>
        
    <div class="related-posts">
      <h3>Related Posts</h3>
      <div class="related-grid">
        
          <a href="../experiments/bootloader.html" class="related-card">
            <h4>Minimal Bare Metal Bootloader</h4>
            <p>**ARM Cortex-M4** • **Bootloader** • **Assembly**</p>
            <span class="tag">experiments</span>
          </a>
        
          <a href="../experiments/esp32-low-power.html" class="related-card">
            <h4>Getting ESP32 to 12µA Sleep Current</h4>
            <p>**Tags:** ESP32 • Low Power • Deep Sleep</p>
            <span class="tag">experiments</span>
          </a>
        
          <a href="../experiments/esp32-adc-performance.html" class="related-card">
            <h4>ESP32 High-Speed ADC Performance: DMA and Interrupt Analysis</h4>
            <p>High-speed analog-to-digital conversion on microcontrollers often becomes CPU-bound long before hitting the advertised sampling rates. The ESP32 integrates two successive approximation register (SAR) </p>
            <span class="tag">experiments</span>
          </a>
        
      </div>
    </div>
  
      </main>
    </div>
  </div>
</section>

  <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border);">
    <div class="container">
      <a href="../experiments.html" style="color: var(--accent); text-decoration: none;">← Back to all experiments</a>
    </div>
  </div>

  
<footer>
  <div class="container">
    <div class="footer-content">
      <div class="footer-logo">
        <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
      </div>
      <p>Fridays with Faraday - Working with microcontrollers and embedded systems</p>
      <div class="footer-links">
        <a href="/rss.xml">RSS Feed</a>
        <a href="https://github.com/yourusername/yourusername.github.io">GitHub</a>
      </div>
    </div>
  </div>
</footer>

  <script src="../js/main.js"></script>
</body>
</html>