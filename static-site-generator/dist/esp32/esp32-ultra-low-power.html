<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Achieving Subâ€‘1ÂµA Sleep Currents on ESP32: A Registerâ€‘Level, Memoryâ€‘ and Timingâ€‘Aware Methodology - Fridays with Faraday</title>
    <meta name="description" content="Ultraâ€‘low power systems demand a disciplined understanding of silicon behavior, memory placement, and clock/power domains. On the ESP32, sleep current is shaped by Dynamic Frequency Scaling (DFS), aut">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml" title="Fridays with Faraday" href="/feed.xml">
</head>
<body>
    <div class="background"></div>
    <div class="grid-overlay"></div>

    
<nav>
  <div class="container">
    <a href="/" class="logo">
      <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
    </a>
    <ul class="nav-menu">
      <li><a href="/#work">Work</a></li>
      <li><a href="/experiments.html" class="active">Experiments</a></li>
      <li><a href="mailto:your.email@example.com">Contact</a></li>
    </ul>
    <div class="nav-search">
      <input type="text" id="search-input" placeholder="Search posts..." />
      <div id="search-results" class="search-results"></div>
    </div>
    <button class="nav-toggle" aria-label="Toggle menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
  </div>
</nav>

    
    <section class="experiment-header">
        <div class="container">
            <h1 class="experiment-title">Achieving Subâ€‘1ÂµA Sleep Currents on ESP32: A Registerâ€‘Level, Memoryâ€‘ and Timingâ€‘Aware Methodology</h1>
            
            <div class="post-header-meta">
              <div class="meta-row">
                <span class="meta-item">
                  <span class="meta-icon">ğŸ“…</span>
                  <time datetime="2025-11-02">November 2, 2025</time>
                </span>
                <span class="meta-item">
                  <span class="meta-icon">ğŸ“–</span>
                  <span>15 min read</span>
                </span>
                <span class="meta-item">
                  <span class="meta-icon">ğŸ“</span>
                  <span>2,996 words</span>
                </span>
                <span class="meta-item">
                  <span class="meta-icon">ğŸ¯</span>
                  <span class="difficulty-badge difficulty-intermediate">Intermediate</span>
                </span>
              </div>
              <div class="post-actions">
                <button onclick="toggleDarkMode()" class="action-btn">ğŸŒ“ Theme</button>
                <button onclick="window.print()" class="action-btn">ğŸ–¨ï¸ Print</button>
              </div>
            </div>
            <p class="post-description">Ultraâ€‘low power systems demand a disciplined understanding of silicon behavior, memory placement, and clock/power domains. On the ESP32, sleep current is shaped by Dynamic Frequency Scaling (DFS), aut</p>
        </div>
    </section>

    <section>
        <div class="container">
            <div class="content-layout">
                <nav class="table-of-contents"><h3>Table of Contents</h3><ul><li style="margin-left: 0px"><a href="#achieving-sub1a-sleep-currents-on-esp32-a-registerlevel-memory-and-timingaware-methodology" class="toc-link">Achieving Subâ€‘1ÂµA Sleep Currents on ESP32: A Registerâ€‘Level, Memoryâ€‘ and Timingâ€‘Aware Methodology</a></li><li style="margin-left: 20px"><a href="#executive-summary-why-sub1a-matters-and-what-it-takes-on-esp32" class="toc-link">Executive Summary: Why Subâ€‘1ÂµA Matters and What It Takes on ESP32</a></li><li style="margin-left: 20px"><a href="#system-overview-memory-map-interrupt-model-and-sleep-architecture" class="toc-link">System Overview: Memory Map, Interrupt Model, and Sleep Architecture</a></li><li style="margin-left: 40px"><a href="#memory-placement-for-lowpower-flows" class="toc-link">Memory Placement for Lowâ€‘Power Flows</a></li><li style="margin-left: 20px"><a href="#registerlevel-deepsleep-control-apis-kconfig-and-wakestub-design" class="toc-link">Registerâ€‘Level Deepâ€‘Sleep Control: APIs, Kconfig, and Wakeâ€‘Stub Design</a></li><li style="margin-left: 40px"><a href="#wakestub-and-ulp-coprocessor-patterns" class="toc-link">Wakeâ€‘Stub and ULP Coâ€‘processor Patterns</a></li><li style="margin-left: 20px"><a href="#measuring-sub1a-sleep-instrumentation-and-oscilloscope-validation" class="toc-link">Measuring Subâ€‘1ÂµA Sleep: Instrumentation and Oscilloscope Validation</a></li><li style="margin-left: 60px"><a href="#measurement-pitfalls-and-remediation" class="toc-link">Measurement pitfalls and remediation</a></li><li style="margin-left: 20px"><a href="#memory-dump-and-isr-analysis-correlating-lowpower-state-with-runtime-data" class="toc-link">Memory Dump and ISR Analysis: Correlating Lowâ€‘Power State with Runtime Data</a></li><li style="margin-left: 20px"><a href="#hardware-modifications-and-boardlevel-adjustments-for-sub1a" class="toc-link">Hardware Modifications and Boardâ€‘Level Adjustments for Subâ€‘1ÂµA</a></li><li style="margin-left: 20px"><a href="#achieving-sub1a-practical-checklists-caveats-and-expected-results" class="toc-link">Achieving Subâ€‘1ÂµA: Practical Checklists, Caveats, and Expected Results</a></li><li style="margin-left: 20px"><a href="#appendix-assembly-snippets-and-memory-maps-for-wake-flows-and-isr-safety" class="toc-link">Appendix: Assembly Snippets and Memory Maps for Wake Flows and ISR Safety</a></li><li style="margin-left: 20px"><a href="#references" class="toc-link">References</a></li></ul></nav>
                <article class="content-section">
                    <p><h1 id="achieving-sub1a-sleep-currents-on-esp32-a-registerlevel-memory-and-timingaware-methodology">Achieving Subâ€‘1ÂµA Sleep Currents on ESP32: A Registerâ€‘Level, Memoryâ€‘ and Timingâ€‘Aware Methodology</h1></p><p><h2 id="executive-summary-why-sub1a-matters-and-what-it-takes-on-esp32">Executive Summary: Why Subâ€‘1ÂµA Matters and What It Takes on ESP32</h2></p><p>Ultraâ€‘low power systems demand a disciplined understanding of silicon behavior, memory placement, and clock/power domains. On the ESP32, sleep current is shaped by Dynamic Frequency Scaling (DFS), auto lightâ€‘sleep, deepâ€‘sleep policy, and how GPIO, RTC, and flash are configured. While Espressifâ€™s lowâ€‘power guide provides indicative averagesâ€”tens of microamps for deepâ€‘sleep with timer/RTC GPIO wake and higher currents for touchpad wakeâ€”achieving a true subâ€‘1 microamp average requires a narrow set of conditions: deepâ€‘sleep with the external crystal and RTC 8 MHz oscillator powered off, flash powered down, GPIOs disabled and rationally biased, and a carefully curated wakeâ€‘source regime, all on a board with minimized leakage and parasitic draws.[^5][^4]</p><p>This post proceeds in four layers. First, we establish the ground truth by mapping memory and interrupts to IRAM/DRAM/RTC domains and explaining DFS and sleep architecture. Second, we define the register/Kconfig levers that materially affect currentâ€”esp_pm_configure, esp_sleep_pd_config, GPIO disablement, and flash powerâ€‘downâ€”and we propose a safe wakeâ€‘stub flow in RTC FAST memory. Third, we specify measurement methodologyâ€”including oscilloscope validation of sleep/wake transitions and current profiling with a shunt and averagingâ€”to evidence subâ€‘1ÂµA intervals. Finally, we enumerate a bill of materials and hardware modificationsâ€”LDO selection, supply isolation, and GPIO biasingâ€”that remove boardâ€‘level leakage paths that otherwise dominate current.</p><p>Scope and information gaps. Achieving subâ€‘1ÂµA sleep currents depends on chip stepping, ROM/IDF version, and board design; Espressifâ€™s public TRM does not document all RTC powerâ€‘down register bitfields; the digital PMU/clock gating matrix is not fully exposed; and quantitative contributions of internal RC drift or ULP monitor impacts are not comprehensively specified. The methodology and caveats here should be interpreted accordingly and repeated on the target silicon and PCB.[^1][^4][^5]</p><p></p><p><h2 id="system-overview-memory-map-interrupt-model-and-sleep-architecture">System Overview: Memory Map, Interrupt Model, and Sleep Architecture</h2></p><p>ESP32â€™s memory and interrupt architecture fundamentally determines the behavior during sleep and wake. Instruction RAM (IRAM) houses latencyâ€‘critical and IRAMâ€‘safe ISR code; DRAM holds data and DMA buffers; RTC FAST memory is available for wake stubs that must execute immediately after deepâ€‘sleep reset; RTC slow memory retains ULP variables across sleep; and the interrupt matrix governs latency, safety, and sharing. Sleep modes gate clocks and power domains, but the residency of code and data across these transitions must be planned.</p><p>To illustrate placement implications, Table 1 summarizes ESP32 memory types and constraints.</p><p>Table 1: ESP32 memory types and constraints relevant to lowâ€‘power design
<tr><td>Memory</td><td>Purpose</td><td>Access</td><td>DMA</td><td>Lowâ€‘power retention</td><td>Typical placement and constraints</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>IRAM (0x40080000â€“0x400A0000)</td><td>Executable code for ISRs and timingâ€‘critical paths</td><td>4â€‘byte aligned word reads</td><td>No</td><td>Lost on deepâ€‘sleep reset (code runs from flash after wake); retained while awake</td><td>Use IRAM_ATTR and ESP_INTR_FLAG_IRAM for ISR code; constants inside IRAM code must use DRAM_ATTR to avoid flash dependencies[^3]</td></tr>
<tr><td>DRAM (0x3FFC0000 region)</td><td>Nonâ€‘constant data, heap, ISRsâ€™ data</td><td>Byteâ€‘addressable</td><td>Yes</td><td>Lost on deepâ€‘sleep reset</td><td>DMA buffers must be in DRAM; use MALLOC_CAP_DRAM/DMA_ATTR; __NOINIT_ATTR for noâ€‘init sections[^3]</td></tr>
<tr><td>IROM</td><td>Executable code from flash via MMU cache</td><td>Cached</td><td>No</td><td>Lost context on deepâ€‘sleep; used after wake</td><td>Default location for app code; cache behavior influences latency[^3]</td></tr>
<tr><td>DROM</td><td>Readâ€‘only constants from flash via MMU cache</td><td>Cached</td><td>No</td><td>Lost context on deepâ€‘sleep</td><td>Use DRAM_ATTR to force constants into DRAM for flashâ€‘unsafe ISRs[^3]</td></tr>
<tr><td>RTC FAST memory</td><td>Code that must run immediately after deepâ€‘sleep wake</td><td>Executable and data</td><td>No</td><td>Retained through deepâ€‘sleep (code persists); only PRO CPU</td><td>Place wake stubs here; not DMAâ€‘capable; slower than IRAM[^3]</td></tr>
<tr><td>RTC slow memory</td><td>Data for ULP and across deepâ€‘sleep</td><td>Data</td><td>No</td><td>Retained through deepâ€‘sleep</td><td>Use RTC_NOINIT_ATTR for variables that must survive sleep[^3]</td></tr></p><p>IRAMâ€‘safe handlers. Use the ESPâ€‘IDF interrupt allocation APIs to register handlers with ESP_INTR_FLAG_IRAM; all code and data the handler uses must reside in IRAM/DRAM. This avoids cache stalls and flash erase/write conflicts during critical handling. Shared interrupts are levelâ€‘triggered; IRAM residency improves determinism and reduces jitter in ISR execution.[^2]</p><p>DFS and sleep modes. DFS modulates CPU/APB frequency based on power locks; auto lightâ€‘sleep leverages tickless idle to suspend the chip when idle time exceeds a threshold; deepâ€‘sleep powers down most of the chip while retaining RTC/LP memory and selected peripherals. Each has implications for code placement and for current draw. Table 2 maps power domains and clock gating options to sleep modes and their impact.</p><p>Table 2: Power domains and clock gating options across sleep modes
<tr><td>Power domain/clock</td><td>Function</td><td>Deepâ€‘sleep default</td><td>Lightâ€‘sleep default</td><td>Kconfig/API control</td><td>Notes for subâ€‘ÂµA design</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>External 40 MHz XTAL</td><td>Highâ€‘accuracy clocks (e.g., Wiâ€‘Fi/BT)</td><td>Powered down</td><td>Typically gated off unless kept</td><td>esp_sleep_pd_config(ESP_PD_DOMAIN_XTAL, â€¦)</td><td>Turn off to reduce leakage; keep only if needed for accurate wake timing or coexisting radios[^4]</td></tr>
<tr><td>Internal 8 MHz RTC OSC</td><td>Powers modules like LEDC</td><td>Powered down</td><td>Gated unless kept</td><td>esp_sleep_pd_config(ESP_PD_DOMAIN_RTC8M, â€¦)</td><td>Turn off to minimize current unless a module must operate during light sleep[^4]</td></tr>
<tr><td>Flash (VCC/PSRAM shared pins)</td><td>Code storage</td><td>Off (deepâ€‘sleep)</td><td>Configurable</td><td>CONFIG_ESP_SLEEP_POWER_DOWN_FLASH</td><td>Power down in lightâ€‘sleep; ensure no PSRAM conflict on shared rails[^4]</td></tr>
<tr><td>GPIO banks</td><td>Digital I/O</td><td>Configurable</td><td>Configurable</td><td>CONFIG_PM_SLP_DISABLE_GPIO; esp_sleep_disable_gpio_wakeup()</td><td>Disabling GPIOs reduces leakage; bias inputs intelligently[^4]</td></tr>
<tr><td>RTC FAST/SLOW memory</td><td>Wake stubs and ULP data</td><td>On</td><td>On</td><td>RTC_NOINIT_ATTR, RTC_FAST_ATTR</td><td>RTC memory retained; plan for stubs/variables accordingly[^3][^5]</td></tr></p><p>
<h3 id="memory-placement-for-lowpower-flows">Memory Placement for Lowâ€‘Power Flows</h3></p><p>Code that must execute immediately after deepâ€‘sleep reset belongs in RTC FAST memory as wake stubs. RTC slow memory should hold ULP program variables and ULP code images. DMA buffers must not be placed on RTC memories; allocate DMA buffers in DRAM with appropriate attributes. IRAMâ€‘safe ISRs reduce latency spikes during flash operations and are essential for any timingâ€‘critical handler that must not miss deadlines under DFS or lightâ€‘sleep transitions.[^3][^2]</p><p></p><p><h2 id="registerlevel-deepsleep-control-apis-kconfig-and-wakestub-design">Registerâ€‘Level Deepâ€‘Sleep Control: APIs, Kconfig, and Wakeâ€‘Stub Design</h2></p><p>At the register and API layer, the levers that matter most for ultraâ€‘low power are:</p><p>- esp_pm_configure to enable DFS and optionally auto lightâ€‘sleep, choosing min/max CPU frequencies to shape idle current.
<ul><ol><li>esp_sleep_pd_config to explicitly power down the external XTAL and internal 8 MHz RTC oscillator in deepâ€‘sleep, and to keep them on only when strictly necessary.</li>
<li>Kconfig flags that disable GPIOs during sleep and power down flash during lightâ€‘sleep, with PSRAM caveats.</li>
<li>Wakeâ€‘stub code placed in RTC FAST memory to execute the earliest postâ€‘wake logic, before the bootloader, to minimize dynamic current during resume.</p><p>To make the tradeâ€‘offs visible, Table 3 summarizes recommended configurations and indicative implications.</p><p>Table 3: Recommended DFS/Lightâ€‘sleep settings for lowâ€‘power apps and expected current impact</li>
<tr><td>Configuration area</td><td>Recommended setting</td><td>Current impact</td><td>Notes</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>DFS</td><td>CONFIG_PM_ENABLE; max_freq_mhz=160; min_freq_mhz=40</td><td>Reduces idle current by lowering CPU/APB frequency</td><td>Shape current during active/idle; suitable when CPU must remain active[^4]</td></tr>
<tr><td>Auto lightâ€‘sleep</td><td>esp_pm_config_t.light_sleep_enable=true; tickless idle; idle time before sleep tuned</td><td>Significant drop during sleep; wake latency exists</td><td>Not suitable for hard realâ€‘time external response[^4]</td></tr>
<tr><td>GPIO disable in sleep</td><td>CONFIG_PM_SLP_DISABLE_GPIO=ON</td><td>Lowers leakage through inputs</td><td>Combine with proper biasing to avoid floating inputs[^4]</td></tr>
<tr><td>Flash powerâ€‘down in light sleep</td><td>CONFIG_ESP_SLEEP_POWER_DOWN_FLASH=ON</td><td>Removes flash current</td><td>Requires careful PSRAM sharing analysis[^4]</td></tr>
<tr><td>RTC clock source</td><td>CONFIG_RTC_CLK_SRC to internal RC where acceptable</td><td>Slightly reduces power vs crystal</td><td>Trade accuracy for power; internal RC has larger offset[^4]</td></tr></p><p>Power domain control is explicit: call esp_sleep_pd_config for ESP_PD_DOMAIN_XTAL and ESP_PD_DOMAIN_RTC8M with ESP_PD_OPTION_OFF in deepâ€‘sleep unless a feature absolutely requires them. Table 4 lists domain choices and subâ€‘1ÂµA implications.</p><p>Table 4: Power domain policy matrix for deepâ€‘sleep
<tr><td>Domain</td><td>Keep ON?</td><td>Rationale</td><td>Implication for subâ€‘1ÂµA</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>XTAL (40 MHz)</td><td>Only if precise timing or radio coexistence required</td><td>Accuracy/stability for modules like BT</td><td>Leave OFF to eliminate a leakage path[^4]</td></tr>
<tr><td>RTC8M (8 MHz)</td><td>Only if modules (e.g., LEDC) must function during lightâ€‘sleep</td><td>Module functionality during sleep</td><td>Leave OFF in deepâ€‘sleep to minimize current[^4]</td></tr>
<tr><td>Flash</td><td>OFF</td><td>Code not executing in deepâ€‘sleep</td><td>Power down to reduce leakage[^4]</td></tr>
<tr><td>RTC memory</td><td>ON</td><td>Required for wake stubs/ULP</td><td>Intentionally retained; does not prevent subâ€‘1ÂµA if other domains are off[^3][^5]</td></tr></p><p>
<h3 id="wakestub-and-ulp-coprocessor-patterns">Wakeâ€‘Stub and ULP Coâ€‘processor Patterns</h3></p><p>Design the earliest postâ€‘wake flow to run from RTC FAST memory (wake stub) and keep ULP program and data in RTC slow memory. The ULP can sample RTC GPIO, the onâ€‘chip temperature sensor, or SAR ADC, store results in RTC slow memory, and act as a wake source based on thresholds. Use helper APIs where appropriate to initialize monitors, but keep the ULP program minimal and infrequent to avoid recurring current spikes.[^5][^3]</p><p></p><p><h2 id="measuring-sub1a-sleep-instrumentation-and-oscilloscope-validation">Measuring Subâ€‘1ÂµA Sleep: Instrumentation and Oscilloscope Validation</h2></p><p>Subâ€‘1ÂµA current is a system property, not a single register setting. It must be measured with instrumentation that resolves microamp currents and short transients. A shuntâ€‘based measurement with a lowâ€‘noise opâ€‘amp and a highâ€‘resolution digitizer is recommended; the shunt should be chosen to keep the voltage headroom within the ESP32â€™s operating range while enabling sufficient resolution at microamp levels. Synchronize current measurements with oscilloscope observations of sleep/wake transitions, using GPIO toggles to mark enter/exit events.</p><p>Table 5 outlines the measurement setup.</p><p>Table 5: Measurement setup overview
<tr><td>Instrument</td><td>Probe points</td><td>Trigger strategy</td><td>Sampling</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td></tr>
<tr><td>Highâ€‘resolution DMM or digitizing amp + scope</td><td>Shunt in series with ESP32 VCC; ground reference near device</td><td>Trigger on GPIO toggle marking sleep entry/exit; capture wakeâ€‘stub execution edge</td><td>Sample current at high rate for integration; use bandwidth limiting to reduce noise</td></tr>
<tr><td>Logic analyzer (optional)</td><td>GPIO debug pins for enter/exit/wakeâ€‘stub activity</td><td>Align logic edges with current trace</td><td>Validate timing of power domain toggles</td></tr>
<tr><td>Temperature/environment log</td><td>Board ambient</td><td>Note environmental variations</td><td>Correlate drift and leakage changes</td></tr></p><p>To validate policy choices, capture traces for configurations with XTAL/RTC8M on vs off, with GPIO disable on vs off, and flash powerâ€‘down on vs off. Use esp_timer_get_time stamps around sleep APIs and GPIO toggles to correlate software events with current behavior. The IDF performance guide recommends microsecondâ€‘level timestamps for timing validation; apply them judiciously given their overhead.[^8] The Espressif IoT Solution guidance on deepâ€‘sleep current averages provides a baseline for expected levels under different wake sources; replicate measurements with identical wake sources to compare results.[^5]</p><p><h4 id="measurement-pitfalls-and-remediation">Measurement pitfalls and remediation</h4></p><p>- Shunt_resistance and burden_voltage: Select a shunt that yields tens of microvolts per microamp; ensure the ESP32â€™s minimum operating voltage is respected under load. Compensate for burden voltage in postâ€‘processing.
<li>Board leakage: Clean flux residues, remove debug LEDs, isolate hopes of PSRAM/flash power domains, and ensure RTC GPIOs are not floating. Real boards often have microamps of parasitic leakage that swamp silicon current.</li>
<li>Temperature dependence: Characterize current across operating temperature; leakage increases with temperature.</li>
<li>Ringing and artifacts: Decouple supplies close to the ESP32; use short ground leads; apply bandwidth limiting during integration to avoid noise spikes that skew average current.</p><p></p><p><h2 id="memory-dump-and-isr-analysis-correlating-lowpower-state-with-runtime-data">Memory Dump and ISR Analysis: Correlating Lowâ€‘Power State with Runtime Data</h2></p><p>Use JTAG with OpenOCD/GDB to halt the system in lowâ€‘power states and dump relevant memory regionsâ€”RTC slow memory contents (RTC_NOINIT_ATTR), IRAM/DRAM for ISR code/data (IRAM_ATTR and DRAM_ATTR), and any noinit sections. The esp_intr_dump API lists allocated and free interrupts with priority and status; use it to confirm the absence of stray shared handlers that could keep the system awake or induce jitter.[^2][^6][^7]</p><p>Assembly patterns for wakeâ€‘stub code should minimize data access to RTC memory only, avoid external RAM and flash, and refrain from invoking heap APIs or complex C++ constructs. Align critical paths with IRAM residency rules: any handler registered with ESP_INTR_FLAG_IRAM and the code it calls must be placed in IRAM; readâ€‘only data it references should be in DRAM (via DRAM_ATTR), not flash.[^2][^3] A postâ€‘mortem core dump analysis on fatal errors can reveal stack corruptions or unexpected ISR activity that coincide with higher sleep current or intermittent wakeâ€‘latency spikes.[^20]</p><p></p><p><h2 id="hardware-modifications-and-boardlevel-adjustments-for-sub1a">Hardware Modifications and Boardâ€‘Level Adjustments for Subâ€‘1ÂµA</h2></p><p>Boardâ€‘level leakage often dominates silicon current. Consider the following:</p><p>- Supply design: Select a lowâ€‘leakage LDO with low quiescent current at light loads; minimize external bias networks on RTC GPIOs; ensure PSRAM/flash power domains do not couple leakage back into ESP32 rails. Follow Espressifâ€™s hardware design guidelines for decoupling and layout recommendations, and be mindful of SDIOâ€‘LDO configurations noted in datasheets.[^16][^17]</li>
<li>GPIO biasing: Turn off INPUT_PULLUP/PULLDOWN on all GPIOs during sleep (CONFIG_PM_SLP_DISABLEGPIO). Float inputs only with deliberate bias to avoid thresholdâ€‘region leakage; route RTC GPIO wake sources cleanly.</li>
<li>Crystal and oscillator: If accurate timing during sleep is not required, keep the external crystal and RTC 8 MHz oscillator powered down via esp_sleep_pd_config; this removes a noticeable leakage contribution compared with leaving them on.[^4]</li>
<li>Crystal load capacitors: Reâ€‘evaluate values if the crystal is kept powered in lightâ€‘sleep for timing accuracy; otherwise, removing or minimizing unnecessary loads reduces dynamic and leakage losses.</li>
<li>SDIO/flash pins: Ensure these are not undriven during sleep; weak pulls can create leakage paths. Review strap pin behavior and kit schematics for deviations.</p><p></p><p><h2 id="achieving-sub1a-practical-checklists-caveats-and-expected-results">Achieving Subâ€‘1ÂµA: Practical Checklists, Caveats, and Expected Results</h2></p><p>The following checklist distills the register/Kconfig/actions needed to maximize deepâ€‘sleep residency at the lowest current.</p><p>Table 6: Subâ€‘1ÂµA deepâ€‘sleep checklist</li>
<tr><td>Item</td><td>Action</td><td>Verification</td></tr>
<tr><td>---</td><td>---</td><td>---</td></tr>
<tr><td>DFS configured</td><td>esp_pm_configure with max/min freq set; optionally enable auto lightâ€‘sleep only if acceptable</td><td>Current falls during idle; tickless behavior observed[^4]</td></tr>
<tr><td>Power domains off</td><td>esp_sleep_pd_config(ESP_PD_DOMAIN_XTAL, OFF); esp_sleep_pd_config(ESP_PD_DOMAIN_RTC8M, OFF)</td><td>No XTAL/RTC8M activity; current drop in deepâ€‘sleep[^4]</td></tr>
<tr><td>Flash powerâ€‘down</td><td>CONFIG_ESP_SLEEP_POWER_DOWN_FLASH=ON (ensure PSRAM not on shared pins)</td><td>Current drop without access latency on wake[^4]</td></tr>
<tr><td>GPIO disable</td><td>CONFIG_PM_SLP_DISABLEGPIO=ON; esp_sleep_disable_gpio_wakeup()</td><td>Reduced input leakage; trace shows lower baseline[^4]</td></tr>
<tr><td>RTC memory retention</td><td>Use RTC_NOINIT_ATTR for variables; keep wake stub in RTC FAST</td><td>Stub executes postâ€‘wake; variables retained[^3]</td></tr>
<tr><td>Board leakage</td><td>Remove debug LEDs, clean flux, isolate rails; measure with shunt</td><td>Parasitic current minimized</td></tr>
<tr><td>ULP scheduling</td><td>ULP runs infrequently; monitors set with thresholds</td><td>Current spikes rare and brief[^5]</td></tr>
<tr><td>Calibration/accuracy</td><td>If internal RC used, accept offset; avoid XTAL if not needed</td><td>Timer accuracy acceptable for app[^4]</td></tr></p><p>Caveats that prevent reaching subâ€‘1ÂµA include leaving XTAL/RTC8M on for convenience, enabling auto lightâ€‘sleep when periodic wake sources causeé¢‘ç¹ wakeâ€‘stub activity, keeping flash powered during lightâ€‘sleep, floating inputs that leak, and boardâ€‘level leakage from sloppy layout or instrumentation. With disciplined configuration and clean hardware, deepâ€‘sleep current can approach the low microamp regime described by Espressifâ€™s lowâ€‘power guide; however, true subâ€‘1ÂµA averages require additional conditionsâ€”particularly complete powerâ€‘down of clocks and external storage, and careful avoidance of board leakage.[^5][^4]</p><p></p><p><h2 id="appendix-assembly-snippets-and-memory-maps-for-wake-flows-and-isr-safety">Appendix: Assembly Snippets and Memory Maps for Wake Flows and ISR Safety</h2></p><p>Below are minimal assembly considerations for wakeâ€‘stub flows and ISR safety; the focus is on residency and minimal data access rather than instruction encoding.</p><p>- Wakeâ€‘stub in RTC FAST: The stub should execute immediately after deepâ€‘sleep reset, before the bootloader. Its responsibilities are minimal: clear reset cause flags, configure the earliest needed clocks (if any), and branch to the bootloader entry. Keep data access to RTC slow memory only, avoid DMA and external RAM, and do not use heap or complex libc functions. Mark the stub code with appropriate RTC FAST attributes according to IDF/RTOS build placement rules.[^3]
<li>IRAMâ€‘safe ISRs: Any ISR registered with ESP_INTR_FLAG_IRAM must have its code in IRAM and any readâ€‘only data it references in DRAM (via DRAM_ATTR). Do not reference flash or external RAM from IRAM handlers; if constants are needed, place them in DRAM using DRAM_ATTR within the IRAM function.[^2][^3]</li>
<li>Disassembly and symbol review: Use nm on the ELF to list symbols in RTC FAST and IRAM sections, confirm .iram.text and .rtc.text regions, and ensure no unexpected references to cached flash or external RAM occur in wakeâ€‘stub code.[^6]</li>
<li>Minimal LED toggle by register (W1TS/W1TC): When debugging wake transitions, it can be useful to drive a GPIO using atomic set/clear registers. For example, on many ESP32 boards, the following patterns toggle an LED on GPIO2 using writeâ€‘1â€‘toâ€‘set and writeâ€‘1â€‘toâ€‘clear semantics; adapt for your boardâ€™s LED GPIO and verify on the TRM. A minimal example (C) for an IRAMâ€‘safe toggle path might look like:</p><p><div class="code-block"><pre><code class="language-text">volatile uint32_t * const GPIO_OUT_W1TS = (volatile uint32_t *)0x3FF44008; // set bits</li></ol></ul>
volatile uint32_t * const GPIO_OUT_W1TC = (volatile uint32_t *)0x3FF4400C; // clear bits
volatile uint32_t * const GPIO_ENABLE_W1TS = (volatile uint32_t *)0x3FF44024; // enable output bits</p><p>void LED_ON(void) { *GPIO_ENABLE_W1TS = (1u &lt;&lt; 2); *GPIO_OUT_W1TS = (1u &lt;&lt; 2); }
void LED_OFF(void) { *GPIO_OUT_W1TC = (1u &lt;&lt; 2); }</code></pre></div></p><p>Use IRAM_ATTR for the functions if they must be latencyâ€‘safe, and mark any constant strings used in debug paths with DRAM_ATTR to keep them out of flash. This approach leverages atomic bit operations and avoids function call overhead; see bareâ€‘metal references for register semantics and boot/startup considerations.[^6][^7]</p><p></p><p><h2 id="references">References</h2></p><p>[^1]: Espressif Systems. ESP32 Technical Reference Manual. https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf  
[^2]: ESPâ€‘IDF Programming Guide (v5.5.1). Interrupt Allocation â€” ESP32. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/intr_alloc.html  
[^3]: ESPâ€‘IDF Programming Guide (v5.5.1). Memory Types â€” ESP32. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/memory-types.html  
[^4]: ESPâ€‘IDF Programming Guide (v5.5.1). Lowâ€‘Power Mode (SoC) â€” ESP32. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/low-power-mode/low-power-mode-soc.html  
[^5]: ESPâ€‘IoTâ€‘Solution (latest). ESP32 Lowâ€‘Power Management. https://docs.espressif.com/projects/esp-iot-solution/en/latest/low_power_solution/esp32_lowpower_solution.html  
[^6]: Getting Started with Bare Metal ESP32 Programming. https://vivonomicon.com/2019/03/30/getting-started-with-bare-metal-esp32-programming/  
[^7]: Baremetal ESP32 Programming: Direct Register Access for LED Control. https://ibrahimmansur4.medium.com/baremetal-esp32-programming-direct-register-access-for-led-control-d4d5b6de28cd  
[^8]: ESPâ€‘IDF Programming Guide (v5.5.1). Maximizing Execution Speed â€” ESP32. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/performance/speed.html  
[^16]: Espressif Systems. ESP32 Hardware Design Guidelines. https://docs.espressif.com/projects/esp-hardware-design-guidelines/en/latest/esp32/esp-hardware-design-guidelines-en-master-esp32.pdf  
[^17]: ESP32 Series Datasheet. https://files.seeedstudio.com/wiki/Spartan-Edge-Accelerator-Board/res/ESP32-datasheet.pdf  
[^20]: ESPâ€‘IDF Programming Guide (v5.5.1). Core Dump â€” ESP32. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/core_dump.html</p>
                </article>
            </div>
            
            
    <div class="social-sharing">
      <h4>Share this post</h4>
      <div class="share-buttons">
        <a href="https://twitter.com/intent/tweet?text=Achieving%20Sub%E2%80%911%C2%B5A%20Sleep%20Currents%20on%20ESP32%3A%20A%20Register%E2%80%91Level%2C%20Memory%E2%80%91%20and%20Timing%E2%80%91Aware%20Methodology&url=https%3A%2F%2Fyour-domain.com%2Fesp32%2Fesp32-ultra-low-power.html" 
           target="_blank" rel="noopener" class="share-btn twitter">Twitter</a>
        <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fyour-domain.com%2Fesp32%2Fesp32-ultra-low-power.html" 
           target="_blank" rel="noopener" class="share-btn linkedin">LinkedIn</a>
        <a href="mailto:?subject=Achieving%20Sub%E2%80%911%C2%B5A%20Sleep%20Currents%20on%20ESP32%3A%20A%20Register%E2%80%91Level%2C%20Memory%E2%80%91%20and%20Timing%E2%80%91Aware%20Methodology&body=Ultra%E2%80%91low%20power%20systems%20demand%20a%20disciplined%20understanding%20of%20silicon%20behavior%2C%20memory%20placement%2C%20and%20clock%2Fpower%20domains.%20On%20the%20ESP32%2C%20sleep%20current%20is%20shaped%20by%20Dynamic%20Frequency%20Scaling%20(DFS)%2C%20aut%0A%0Ahttps%3A%2F%2Fyour-domain.com%2Fesp32%2Fesp32-ultra-low-power.html" 
           class="share-btn email">Email</a>
        <button onclick="navigator.clipboard.writeText('https://your-domain.com/esp32/esp32-ultra-low-power.html'); this.innerHTML='Copied!'; setTimeout(() => this.innerHTML='Copy Link', 2000);" 
                class="share-btn copy">Copy Link</button>
      </div>
    </div>
  
            <div class="post-navigation"><div class="nav-previous">
                  <a href="esp32/esp32-power-management.html">
                    <span class="nav-label">â† Previous</span>
                    <span class="nav-title">ESP32 Power Management Trade-offs: Register-Level Investigation</span>
                  </a>
                </div><div class="nav-next">
                  <a href="esp32/esp32-wifi-performance.html">
                    <span class="nav-label">Next â†’</span>
                    <span class="nav-title">ESP32 Real-Time WiFi Performance: MAC Layer Analysis</span>
                  </a>
                </div></div>
            
    <section class="related-posts">
      <h3>Related Posts</h3>
      <div class="related-grid">
        
          <article class="related-post">
            <h4><a href="esp32/esp32-adc-performance.html">ESP32 High-Speed ADC Performance: DMA and Interrupt Analysis</a></h4>
            <p>High-speed analog-to-digital conversion on microcontrollers often becomes CPU-bound long before hitting the advertised s...</p>
            <div class="related-meta">
              <span class="reading-time">14 min read</span>
              <span class="difficulty">Advanced</span>
            </div>
          </article>
        
          <article class="related-post">
            <h4><a href="esp32/esp32-power-management.html">ESP32 Power Management Trade-offs: Register-Level Investigation</a></h4>
            <p>Power management on ESP32 involves complex trade-offs between voltage regulation efficiency, clock configuration optimiz...</p>
            <div class="related-meta">
              <span class="reading-time">21 min read</span>
              <span class="difficulty">Advanced</span>
            </div>
          </article>
        
          <article class="related-post">
            <h4><a href="esp32/esp32-wifi-performance.html">ESP32 Real-Time WiFi Performance: MAC Layer Analysis</a></h4>
            <p>Achieving reliable real-time WiFi performance on ESP32 presents unique challenges due to the complex interactions betwee...</p>
            <div class="related-meta">
              <span class="reading-time">18 min read</span>
              <span class="difficulty">Advanced</span>
            </div>
          </article>
        
      </div>
    </section>
  
            
            <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border);">
                <a href="/experiments.html" style="color: var(--accent); text-decoration: none;">â† Back to all experiments</a>
            </div>
        </div>
    </section>

    
<footer>
  <div class="container">
    <div class="footer-content">
      <div class="footer-logo">
        <span class="logo-f">f</span><span class="logo-slash">/</span><span class="logo-f">f</span>
      </div>
      <p>Fridays with Faraday - Working with microcontrollers and embedded systems</p>
    </div>
  </div>
</footer>

    <script src="/js/main.js"></script>
</body>
</html>
